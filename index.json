[{"content":"整数二分 思想\n模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  bool check(int x) {/* ... */} // 检查x是否满足某种性质  // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) {  while (l \u0026lt; r)  {  int mid = l + r \u0026gt;\u0026gt; 1;  if (check(mid)) r = mid; // check()判断mid是否满足性质  else l = mid + 1;  }  return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) {  while (l \u0026lt; r)  {  int mid = l + r + 1 \u0026gt;\u0026gt; 1;  if (check(mid)) l = mid;  else r = mid - 1;  }  return l; }   数组中数值和下标相等的元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public:  int getNumberSameAsIndex(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int n = nums.size();  int l =0,r=n-1;  while(l\u0026lt;=r){  int mid = (l+r)\u0026gt;\u0026gt;1;  if(mid==nums[mid]) return mid;  else if(mid\u0026gt;nums[mid]) l=mid+1;  else r=mid-1;  }  return -1;  } };   数字在排序数组中出现的次数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public:  int getNumberOfK(vector\u0026lt;int\u0026gt;\u0026amp; nums , int k) {  int res = 0;  if(nums.size()==0) return 0;  int l=0,r=nums.size()-1;  while(l\u0026lt;r){  int mid = (l+r)\u0026gt;\u0026gt;1;  if(nums[mid]\u0026lt;k) l=mid+1;  else r=mid;  }  int a = l;  if(nums[a]!=k) return 0;  l=0,r=nums.size()-1;  while(l\u0026lt;r){  int mid = (l+r+1)\u0026gt;\u0026gt;1;  if(nums[mid]\u0026lt;=k) l=mid;  else r=mid-1;  }  return r-a+1;  } };   0到n-1中缺失的数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public:  int getMissingNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  if (nums.empty()) return 0;  int l =0,r=nums.size()-1;  while(l\u0026lt;r){  int mid = l+r\u0026gt;\u0026gt;1;  if(mid\u0026lt;nums[mid]) r = mid;  else l=mid+1;  }  if(nums[r]==r) r++;  return r;  } };   旋转数组的最小数字    不修改数组找出重复的数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public:  int duplicateInArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int l =0,r=nums.size()-1;  while(l\u0026lt;r){  int mid = l+r\u0026gt;\u0026gt;1;  int t = 0;  for(auto x:nums) t+= x\u0026gt;=nums[l]\u0026amp;\u0026amp;x\u0026lt;=nums[mid];  if(t\u0026gt;mid-l+1) r=mid;  else l = mid+1;  }  return r;   } };   ","permalink":"https://kevinerr.github.io/posts/algorithm/%E4%BA%8C%E5%88%86/","summary":"整数二分 思想 模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和","title":"二分"},{"content":"[]: https://www.acwing.com/problem/content/description/3765/\n二进制矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std;  const int N = 110;  int n, m; char g[N][N];  void pL(int i, int j, int k) {  if (!k) printf(\u0026#34;%d %d %d %d %d %d\\n\u0026#34;, i, j, i + 1, j, i, j + 1);  //尖尖左上角  else if (k == 1) printf(\u0026#34;%d %d %d %d %d %d\\n\u0026#34;, i, j - 1, i, j, i + 1, j);  //尖尖右上角  else if (k == 2) printf(\u0026#34;%d %d %d %d %d %d\\n\u0026#34;, i - 1, j, i, j, i, j - 1);  //尖尖右下角  else printf(\u0026#34;%d %d %d %d %d %d\\n\u0026#34;, i - 1, j, i, j, i, j + 1);  //尖尖左下角 }  int main() {  int T;  cin \u0026gt;\u0026gt; T;  while (T -- )  {  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;  int res = 0;  for (int i = 1; i \u0026lt;= n; i ++ )  {  cin \u0026gt;\u0026gt; g[i] + 1;  for (int j = 1; j \u0026lt;= m; j ++ )  if (g[i][j] == \u0026#39;1\u0026#39;)  res += 3;  }  cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;  for (int i = 1; i \u0026lt;= n; i ++ )  for (int j = 1; j \u0026lt;= m; j ++ )  if (g[i][j] == \u0026#39;1\u0026#39;)  {  if (i \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m)  pL(i, j, 0), pL(i, j + 1, 1), pL(i + 1, j, 3);  else if (i == n \u0026amp;\u0026amp; j == m)  pL(i, j, 2), pL(i - 1, j, 1), pL(i, j - 1, 3);  else if (i == n)  pL(i, j, 3), pL(i - 1, j, 0), pL(i, j + 1, 2);  else  pL(i, j, 1), pL(i, j - 1, 0), pL(i + 1, j, 2);  }  }  return 0; }   数字矩阵 三元数异或 兔子跳 亮灯时长 数组补全 点 战舰 质数问题 解码 构造字符串 幸运年份 ","permalink":"https://kevinerr.github.io/posts/algorithm/2021%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E6%9A%91%E5%81%87/","summary":"[]: https://www.acwing.com/problem/content/description/3765/ 二进制矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const","title":"2021每日一题暑假"},{"content":"排序的问题基本都是让我们利用各种排序的思想去解决其他问题的\n快排 思想 快速排序所采用的思想是分治的思想。所谓分治，就是指以一个数为基准，将序列中的其他数往它两边“扔”。以从小到大排序为例，比它小的都“扔”到它的左边，比它大的都“扔”到它的右边，然后左右两边再分别重复这个操作，不停地分，直至分到每一个分区的基准数的左边或者右边都只剩一个数为止。这时排序也就完成了。\n快排模板 1 2 3 4 5 6 7 8 9 10 11 12 13  void quick_sort(int q[], int l, int r) {  if (l \u0026gt;= r) return;   int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1];  while (i \u0026lt; j)  {  do i ++ ; while (q[i] \u0026lt; x);  do j -- ; while (q[j] \u0026gt; x);  if (i \u0026lt; j) swap(q[i], q[j]);  }  quick_sort(q, l, j), quick_sort(q, j + 1, r); }   32、调整数组顺序使奇数位于偶数前面 1 2 3 4 5 6 7 8 9 10 11  class Solution { public:  void reOrderArray(vector\u0026lt;int\u0026gt; \u0026amp;array) {  int l = 0, r = array.size() - 1;  while (l \u0026lt; r) {  while (l \u0026lt; r \u0026amp;\u0026amp; array[l] % 2 == 1) l ++ ;  while (l \u0026lt; r \u0026amp;\u0026amp; array[r] % 2 == 0) r -- ;  if (l \u0026lt; r) swap(array[l], array[r]);  }  } };   普通归并 思想 分治思想：分：划分成很多个小的问题，然后递归处理，治：将分阶段得到的答案整合起来，即为分治思想。\n归并模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  void merge_sort(int q[], int l, int r) {  if (l \u0026gt;= r) return;   int mid = l + r \u0026gt;\u0026gt; 1;  merge_sort(q, l, mid);  merge_sort(q, mid + 1, r);   int k = 0, i = l, j = mid + 1;  while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r)  if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ];  else tmp[k ++ ] = q[j ++ ];   while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ];  while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ];   for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; }   65、数组中的逆序对 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public:  int res = 0;  int b[100];  void merge_sort(vector\u0026lt;int\u0026gt;\u0026amp; a,int l,int r){  if(l\u0026gt;=r) return;  int mid = l+r\u0026gt;\u0026gt;1;  merge_sort(a,l,mid);  merge_sort(a,mid+1,r);  int k = l,i=l,j=mid+1;  while(i\u0026lt;=mid\u0026amp;\u0026amp;j\u0026lt;=r){  if(a[i]\u0026lt;=a[j]) b[k++]=a[i++];  else{  b[k++]=a[j++];  res+=mid-i+1;  }  }  while(i\u0026lt;=mid) b[k++]=a[i++];  while(j\u0026lt;=r) b[k++]=a[j++];  for(i=l;i\u0026lt;=r;i++) a[i]=b[i];  }  int inversePairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  merge_sort(nums,0,nums.size()-1);  return res;  } };   三路归并 62、丑数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public:  int getUglyNumber(int n) {  if(n \u0026lt;= 1) return n;  vector\u0026lt;int\u0026gt; f(1,1);  int i = 0, j = 0, k = 0;  long long t = 0;  while(--n)  {  t = min({f[i] * 2,f[j] * 3, f[k] * 5});  if(t == f[i] * 2) i++;  if(t == f[j] * 3) j++;  if(t == f[k] * 5) k++;  f.push_back(t);  }  return f.back();   } };   ","permalink":"https://kevinerr.github.io/posts/algorithm/%E6%8E%92%E5%BA%8F/","summary":"排序的问题基本都是让我们利用各种排序的思想去解决其他问题的 快排 思想 快速排序所采用的思想是分治的思想。所谓分治，就是指以一个数为基准，将序列中","title":"排序"},{"content":"滑动窗口法 什么情况下会想到滑动窗口法：\n任何题目如果没有思路其实都可以想一下暴力解法。这道题暴力解法思路简单：\n遍历任意i，j，使得i和j之间的子串长度，等于p串的长度。该子串称之为x。该步复杂度为O（n）。 判断x是否与p是异位词。是的话，则把i加入答案中。该步复杂度为O（n）。 暴力法的复杂度为O（n^2）。显然不高效。\n可以发现第二步其实做了很多不必要的操作，例如[i, j]和[i+1, j+1]两个子串在暴力法第二步中，需要各遍历一次，完全没必要。其实[i+1, j+1]完全可以在[i, j]的基础上做判断，也就是去掉头部的字符（i位置），加上尾部的字符（j+1位置）。这样第一步的复杂度可以降到O(1)。整体复杂度降到O(n)。已经得到信息不重复使用就浪费了，没必要重新搜集近乎相同的信息。这就是滑动窗口法。\n滑动窗口法的特点是，一连串元素的信息，可以用常数时间推断出，该串整体移位后，新串信息。\n所有滑动窗口问题，如果能从暴力法优化的角度思考，都不难想到。\nmedium 3. 无重复字符的最长子串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public:  int lengthOfLongestSubstring(string s) {  int n =s.length();  unordered_set\u0026lt;char\u0026gt; st;  if(n==0) return 0;  int maxStr = 0,left=0;  for(int i =0;i\u0026lt;n;i++){  while(st.find(s[i])!=st.end()){  st.erase(s[left]);  left++;   }  st.insert(s[i]);  maxStr = max(maxStr,i-left+1);  }  return maxStr;  } };   643. 子数组最大平均数 I 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public:  double findMaxAverage(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) {  double res=-5e4-5.5;  int n = nums.size(),left=0,len=0;  double sum = 0.0;  for(int i =0;i\u0026lt;n;i++){  sum+=nums[i];  len++;  while(len==k){  res=max(res,sum/k);  sum-=nums[left];  left++;  len--;  }  }  return res;  } };   209. 长度最小的子数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public:  int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int n = nums.size();  int left=0,res=n,sum=0;  bool flag =false;  for(int i = 0;i\u0026lt;n;i++){  sum+=nums[i];  while(sum\u0026gt;=target){  res=min(res,i-left+1);  sum-=nums[left];  left++;  flag=true;  }  }  if(flag) return res;  else return 0;  } };   1695. 删除子数组的最大得分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public:  int maximumUniqueSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int n = nums.size();  unordered_set\u0026lt;int\u0026gt; st;  int left =0;  int res =0,sum=0;  for(int i =0;i\u0026lt;n;i++){  while(st.find(nums[i])!=st.end()){  st.erase(nums[left]);  sum-=nums[left];  left++;  }  st.insert(nums[i]);  sum+=nums[i];  res=max(res,sum);  }  return res;  } };   438. 找到字符串中所有字母异位词 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public:  vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) {  vector\u0026lt;int\u0026gt; result;  int n = s.length(),m=p.length();  if(n\u0026lt;m) return result;  vector\u0026lt;int\u0026gt; a(26,0);  vector\u0026lt;int\u0026gt; b(26,0);  for(int i =0;i\u0026lt;m;i++) b[p[i]-\u0026#39;a\u0026#39;]++;  int left = 0;  for(int i =0;i\u0026lt;n;i++){  a[s[i]-\u0026#39;a\u0026#39;]++;  if(i\u0026gt;=m){  a[s[left]-\u0026#39;a\u0026#39;]--;  left++;  }  if(a==b) result.push_back(left);  }  return result;  } };   567. 字符串的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public:  bool checkInclusion(string s1, string s2) {  int n = s1.length(),m=s2.length();  if(n\u0026gt;m) return false;  vector\u0026lt;int\u0026gt; a(26,0);  vector\u0026lt;int\u0026gt; b(26,0);  for(int i = 0;i\u0026lt;n;i++){  a[s1[i]-\u0026#39;a\u0026#39;]++;  }  int left=0;  for(int i =0;i\u0026lt;m;i++){  b[s2[i]-\u0026#39;a\u0026#39;]++;  if(i\u0026gt;=n){  b[s2[left]-\u0026#39;a\u0026#39;]--;  left++;  }  if(a==b) return true;  }  return false;  } };   1004. 最大连续1的个数 III 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public:  int longestOnes(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) {  int n = nums.size();  deque\u0026lt;int\u0026gt; a;  int res = 0;  for(int i =0;i\u0026lt;n;i++){  while(k==0\u0026amp;\u0026amp;nums[i]==0){  if(a.front()==1){  a.pop_front();  }else{  a.pop_front();  k++;  }  }  if(nums[i]==0){  k--;  }  a.push_back(nums[i]);  int t = a.size();  res=max(res,t);   }  return res;  } };   1208. 尽可能使字符串相等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public:  int equalSubstring(string s, string t, int maxCost) {  int res = 0;  int n = s.length();  int a[n];  vector\u0026lt;int\u0026gt; b(n,0);  for(int i =0;i\u0026lt;n;i++){  a[i]=abs(s[i]-t[i]);  }  int left=0,len=0;  for(int i = 0;i\u0026lt;n;i++){  b[i]=a[i];  maxCost-=a[i];  len++;  while(maxCost\u0026lt;0){  maxCost+=b[left];  left++;  len--;  }  res=max(res,len);  }  return res;  } };   1052. 爱生气的书店老板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public:  int maxSatisfied(vector\u0026lt;int\u0026gt;\u0026amp; customers, vector\u0026lt;int\u0026gt;\u0026amp; grumpy, int minutes) {  int n = customers.size();  int sum = 0;  int res=0;  vector\u0026lt;int\u0026gt; v;  for(int i =0;i\u0026lt;n;i++){  if(grumpy[i]==0) sum+=customers[i];  else{  v.push_back(i);  }  }  int left = 0;  for(int i =0;i\u0026lt;v.size();i++){  while(v[i]-v[left]\u0026gt;=minutes){  sum-=customers[v[left]];  left++;  }  sum+=customers[v[i]];  res=max(res,sum);  }  res=max(res,sum);  return res;  } };   1423. 可获得的最大点数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public:  int maxScore(vector\u0026lt;int\u0026gt;\u0026amp; cardPoints, int k) {  int n = cardPoints.size();  int res = 0,sum=0,left=n-k,len=k;  vector\u0026lt;int\u0026gt; d;  for(int i = 0;i\u0026lt;n;i++){  d.push_back(cardPoints[i]);  }  for(int i = 0;i\u0026lt;n;i++){  d.push_back(cardPoints[i]);  }  for(int i =n-k;i\u0026lt;n+k;i++){  sum+=d[i];  len--;  res=max(res,sum);  if(len==0){  sum-=d[left];  left++;  len++;  }  }  return res;  } };   hard 30. 串联所有单词的子串 思路 总共用到两个哈希表，allWordsMap用于记录words中单词出现的次数，nowWordsMap用于记录子串中（也就是滑动窗口中）单词出现的次数 num为单词的个数，onelen为单词长度 遍历字符串，移动长度为 num* onelen的滑动窗口，再在当前滑动窗口中依次比较onelen长度的单词 当这个窗口内一旦出现不存在allWordsMap中的单词，或者这个单词在子串中出现的次数已经等于allWordsMap中的次数(也就是再加入这个子串次数就要超出了)，这个滑动窗口就不符合要求，直接break进入下一个滑动窗口的匹配 一旦完全匹配上了，把滑动窗口的起始索引加入结果res中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Solution { public:  vector\u0026lt;int\u0026gt; findSubstring(string s, vector\u0026lt;string\u0026gt;\u0026amp; words) {  unordered_map\u0026lt;string, int\u0026gt; allWordsMap;  for (auto\u0026amp; v : words) {  allWordsMap[v]++;  }   int num = words.size();  int onelen = words[0].length();  vector\u0026lt;int\u0026gt; res;  if (s.length() \u0026lt; num * onelen) {  return res;  }   for (int left = 0; left \u0026lt; s.length() - num * onelen + 1; ++left)  {  unordered_map\u0026lt;string, int\u0026gt; nowWordsMap;  int right = left;  while (right \u0026lt; left + num * onelen) {  auto cur = s.substr(right, onelen);  if (allWordsMap.find(cur) == allWordsMap.end()  || nowWordsMap[cur] == allWordsMap[cur]) {  break;  }   ++nowWordsMap[cur];  right += onelen;  }   if (right == left + num * onelen) {  res.push_back(left);  }  }   return res;  } };   76. 最小覆盖子串 239. 滑动窗口最大值 ","permalink":"https://kevinerr.github.io/posts/algorithm/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","summary":"滑动窗口法 什么情况下会想到滑动窗口法： 任何题目如果没有思路其实都可以想一下暴力解法。这道题暴力解法思路简单： 遍历任意i，j，使得i和j之间的","title":"滑动窗口"},{"content":"代码 MMO游戏 大型多人在线游戏\n","permalink":"https://kevinerr.github.io/posts/tech/zinx-learn/","summary":"代码 MMO游戏 大型多人在线游戏","title":"Zinx Learn"},{"content":"简单模块 1、两数之和 简单题，用unordered_map\u0026lt;int,int\u0026gt; um;key为值，value为数组下标\n遍历一遍，看um中是否有和为target的另一半，并且另一半的数组下标不能相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public:  vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) {  vector\u0026lt;int\u0026gt; res;  unordered_map\u0026lt;int,int\u0026gt; um;  for(int i =0;i\u0026lt;nums.size();i++){  um[nums[i]]=i;  }  for(int i=0;i\u0026lt;nums.size();i++){  int k =target-nums[i];  if(um.count(k) \u0026amp;\u0026amp; um[k]!=i){ //WA一次，没考虑um[k]!=i  res.push_back(i);  res.push_back(um[k]);  break;  }  }  return res;  } };   20、有效的括号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public:  bool isValid(string s) {  stack\u0026lt;char\u0026gt; st;  for(int i =0;i\u0026lt;s.length();i++){  if(s[i]==\u0026#39;(\u0026#39;){  st.push(\u0026#39;)\u0026#39;);  }else if(s[i]==\u0026#39;[\u0026#39;){  st.push(\u0026#39;]\u0026#39;);  }else if(s[i]==\u0026#39;{\u0026#39;){  st.push(\u0026#39;}\u0026#39;);  }else{  if(st.size()\u0026amp;\u0026amp;s[i]==st.top()){ //WA一次，没考虑st.size()  st.pop();  continue;  }else{  return false;  }  }  }  if(st.size()) return false;  else return true;  } };   21、合并2个有序链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  //思路一：迭代 class Solution { public:  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {  ListNode * dummy = new ListNode(0); //创建哑结点  ListNode * p = dummy; //新链表的工作指针  //如果两个都不为空  while(list1!=NULL\u0026amp;\u0026amp;list2!=NULL){  //先把list1中小的元素放到新链表中  if(list1-\u0026gt;val\u0026lt;=list2-\u0026gt;val){  p-\u0026gt;next = list1;  list1=list1-\u0026gt;next;  p=p-\u0026gt;next;  }  else{  p-\u0026gt;next = list2;  list2=list2-\u0026gt;next;  p=p-\u0026gt;next;  }  }  //如果list1空了，list2不空  if(list2!=NULL){  //把list2剩下部分放进去  p-\u0026gt;next =list2;  }  //如果list2空了，list1不空  if(list1!=NULL){  //把list1剩下部分放进去  p-\u0026gt;next = list1;  }  return dummy-\u0026gt;next;  } };   53、最大子数组和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public:  int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int len = nums.size();  int dp[len];  int res = -10005;  dp[0]=nums[0];  for(int i =1;i\u0026lt;len;i++){  dp[i]=max(dp[i-1]+nums[i],nums[i]);  }  for(int i =0;i\u0026lt;len;i++){  res=max(res,dp[i]);  }  return res;  } };   70、爬楼梯 递归超时了\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public:  int get(int n){  if(n==1) return 1;  else if(n==2) return 2;  else return get(n-1)+get(n-2);  }  int climbStairs(int n) {  return get(n);  } };   改用dp\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public:  int dp[48];  int climbStairs(int n) {  dp[1]=1;  dp[2]=2;  for(int i =3;i\u0026lt;=n;i++){  dp[i]=dp[i-1]+dp[i-2];  }  return dp[n];  } };   94、二叉树的中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public:  vector\u0026lt;int\u0026gt; res;  void dfs(TreeNode* root){  if(root-\u0026gt;left) dfs(root-\u0026gt;left);  res.push_back(root-\u0026gt;val);  if(root-\u0026gt;right) dfs(root-\u0026gt;right);  }  vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) {  if(root==nullptr) return res;  dfs(root);  return res;  } };   101、对称二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public:  bool isSame(TreeNode* l,TreeNode* r){  if(!l\u0026amp;\u0026amp;!r) return true;  if(!l\u0026amp;\u0026amp;r||l\u0026amp;\u0026amp;!r) return false;  if(l-\u0026gt;val==r-\u0026gt;val){  return isSame(l-\u0026gt;left,r-\u0026gt;right)\u0026amp;\u0026amp;isSame(l-\u0026gt;right,r-\u0026gt;left);  }  return false;   }  bool isSymmetric(TreeNode* root) {  if(!root-\u0026gt;left\u0026amp;\u0026amp;!root-\u0026gt;right) return true;  if(root-\u0026gt;left\u0026amp;\u0026amp;root-\u0026gt;right) return isSame(root-\u0026gt;left,root-\u0026gt;right);  return false;  } };   104、二叉树的最大深度 dfs\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public:  int dfs(TreeNode* root){  if(!root) return 0;  int l = 1+dfs(root-\u0026gt;left);  int r = 1+dfs(root-\u0026gt;right);  return max(l,r);  }  int maxDepth(TreeNode* root) {  return dfs(root);  } };   bfs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public:  int maxDepth(TreeNode* root) {  int res = 0;  if(!root) return res;  queue\u0026lt;TreeNode*\u0026gt; q;  q.push(root);  while(q.size()){  int len = q.size();  res++;  for(int i =0;i\u0026lt;len;i++){  auto t = q.front();  q.pop();  if(t-\u0026gt;left) q.push(t-\u0026gt;left);  if(t-\u0026gt;right) q.push(t-\u0026gt;right);  }  }  return res;  } };   121、买卖股票的最佳时机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public:  int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) {  int n = prices.size();  int res =0;  int dp[n]; //dp[i]表示前i个元素中的最小元素  dp[0]=prices[0];  for(int i =1;i\u0026lt;n;i++){  dp[i]=min(prices[i],dp[i-1]);  }  for(int i =0;i\u0026lt;n;i++){  res=max(res,prices[i]-dp[i]);  }  return res;  } };   1 2 3 4 5 6 7 8 9 10 11 12 13  //空间优化版本 class Solution {  public int maxProfit(int[] prices) {  if(prices.length \u0026lt;= 1)  return 0;  int min = prices[0], max = 0;  for(int i = 1; i \u0026lt; prices.length; i++) {  max = Math.max(max, prices[i] - min);  min = Math.min(min, prices[i]);  }  return max;  } }   136、只出现一次的数 1 2 3 4 5 6 7 8 9 10  class Solution { public:  int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int res=0;  for(int i =0;i\u0026lt;nums.size();i++){  res^=nums[i]; //2个相同的数异或为0，0异或任意一个数等于这个数  }  return res;  } };   141、环形链表 1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public:  bool hasCycle(ListNode *head) {  ListNode *one =head;  ListNode *two = head;  while(two!=NULL\u0026amp;\u0026amp;two-\u0026gt;next!=NULL){  one=one-\u0026gt;next;two=two-\u0026gt;next-\u0026gt;next;  if(one==two) return true;  }  return false;  } };   key:一快一慢 总会想见\n155、最小栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class MinStack { public:  /** initialize your data structure here. */  MinStack() {  }   void push(int x) {  if (st.size() == 0) {  st.push({x, x});  } else {  st.push({x, min(x, st.top().second)});  }  }   void pop() {  st.pop();  }   int top() {  return st.top().first;  }   int getMin() {  return st.top().second;  } private:  stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; st; };   key:妙用pair\n160、相交链表 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public:  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {  if(headA == NULL || headB == NULL) return NULL;  ListNode* curA = headA;  ListNode* curB = headB;  while(curA != curB) {  curA = curA == NULL ? headB : curA-\u0026gt;next;  curB = curB == NULL ? headA : curB-\u0026gt;next;  }  return curA;  } };   key:我走过你来时的路\n169、多数元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public:  int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int m = nums[0];  int count =1;  for(int i =1;i\u0026lt;nums.size();i++){  if(nums[i]==m) count++;  else count--;  if(count==0){  m=nums[i];  count =1;  }  }  return m;  } };   key:摩尔投票法\n有一个对摩尔投票法非常形象的比喻：多方混战。\n首先要知道，在任何数组中，出现次数大于该数组长度1/3的值最多只有两个。\n我们把这道题比作一场多方混战，战斗结果一定只有最多两个阵营幸存，其他阵营被歼灭。数组中的数字即代表某士兵所在的阵营。\n我们维护两个潜在幸存阵营A和B。我们遍历数组，如果遇到了属于A或者属于B的士兵，则把士兵加入A或B队伍中，该队伍人数加一。继续遍历。\n如果遇到了一个士兵既不属于A阵营，也不属于B阵营，这时有两种情况：\n情况一：A阵营和B阵营都还有活着的士兵，那么进行一次厮杀，参与厮杀的三个士兵全部阵亡：A阵营的一个士兵阵亡，B阵营的一个士兵阵亡，这个不知道从哪个阵营来的士兵也阵亡。继续遍历。\n情况二：A阵营或B阵营已经没有士兵了。没有士兵的阵营暂时从地球上消失了。那么把当前遍历到的新士兵算作新的潜在幸存阵营，这个新阵营只有他一个人。继续遍历。\n大战结束，最后A和B阵营就是初始人数最多的阵营。判断一下A，B的人数是否超过所有人数的三分之一就行了。\n229、求众数2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  class Solution { public:  vector\u0026lt;int\u0026gt; majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  vector\u0026lt;int\u0026gt; ans;  int element1 = 0;  int element2 = 0;  int vote1 = 0;  int vote2 = 0;  for(auto num:nums){  if(vote1\u0026gt;0\u0026amp;\u0026amp;num==element1){  vote1++;  }else if(vote2\u0026gt;0\u0026amp;\u0026amp;num==element2){  vote2++;  }else if(vote1==0){  vote1++;  element1=num;  }else if(vote2==0){  vote2++;  element2=num;  }else{  vote1--;  vote2--;  }  }  int cnt1 = 0;  int cnt2 = 0;  for (auto \u0026amp; num : nums) {  if (vote1 \u0026gt; 0 \u0026amp;\u0026amp; num == element1) {  cnt1++;  }  if (vote2 \u0026gt; 0 \u0026amp;\u0026amp; num == element2) {  cnt2++;  }  }  // 检测元素出现的次数是否满足要求  if (vote1 \u0026gt; 0 \u0026amp;\u0026amp; cnt1 \u0026gt; nums.size() / 3) {  ans.push_back(element1);  }  if (vote2 \u0026gt; 0 \u0026amp;\u0026amp; cnt2 \u0026gt; nums.size() / 3) {  ans.push_back(element2);  }   return ans;   } };   206、反转链表 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public:  ListNode* reverseList(ListNode* head) {  ListNode* cur = NULL, *pre = head;  while (pre != NULL) {  ListNode* t = pre-\u0026gt;next;  pre-\u0026gt;next = cur;  cur = pre;  pre = t;  }  return cur;  } };   226、翻转二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public:  TreeNode* invertTree(TreeNode* root) {  if(!root) return nullptr;  TreeNode* t =root-\u0026gt;left;  root-\u0026gt;left=root-\u0026gt;right;  root-\u0026gt;right=t;  if(root-\u0026gt;left){  invertTree(root-\u0026gt;left);  }  if(root-\u0026gt;right){  invertTree(root-\u0026gt;right);  }  return root;  } };   234、回文链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public:  bool isPalindrome(ListNode* head) {  stack\u0026lt;int\u0026gt; st;  ListNode* p = head;  while(p){  st.push(p-\u0026gt;val);  p=p-\u0026gt;next;  }  while(head){  if(head-\u0026gt;val!=st.top()) return false;  head=head-\u0026gt;next;  st.pop();  }  return true;  } };   283、移动零 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public:  void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int len = nums.size();  int j=0;  for(int i=0;i\u0026lt;len;i++){  if(nums[i]!=0){  nums[j]=nums[i];  j++;  }  }  for(;j\u0026lt;len;j++){  nums[j]=0;  }  } };   338、比特位计数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public:  vector\u0026lt;int\u0026gt; countBits(int n) {  vector\u0026lt;int\u0026gt; res(n+1);  for(int i =0;i\u0026lt;=n;i++){  int cnt = 0;  int j =i;  while(j){  if(j\u0026amp;1) cnt++;  j=j\u0026gt;\u0026gt;1;  }  res[i]=cnt;  }  return res;  } };   1 2 3 4 5 6 7 8 9 10 11  public class Solution {  public int[] CountBits(int n) {  //x = x\u0026amp;(x-1),清除最低位的1  int[] bits = new int[n+1];  for(int i=1;i\u0026lt;=n;i++)  {  bits[i] = bits[i\u0026amp;(i-1)]+1;  }  return bits;  } }   key:x = x \u0026amp; (x-1)\n448、找到所有数组中消失的元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public:  vector\u0026lt;int\u0026gt; findDisappearedNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  vector\u0026lt;int\u0026gt; res;  set\u0026lt;int\u0026gt; st;  for(int i =0;i\u0026lt;nums.size();i++){  st.insert(nums[i]);  }  for(int i =1;i\u0026lt;=nums.size();i++){  if(!st.count(i)){  res.push_back(i);  }  }  return res;  } };   461、汉明距离 1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public:  int hammingDistance(int x, int y) {  int res=0;  while(x||y){  res+= (x\u0026amp;1)^(y\u0026amp;1);  x=x\u0026gt;\u0026gt;1;  y=y\u0026gt;\u0026gt;1;  }  return res;  } };   543、二叉树的直径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public:  int res = 0;  int dfs(TreeNode* root){  if(!root) return 0;  int l = 1+dfs(root-\u0026gt;left);  int r = 1+dfs(root-\u0026gt;right);  res = max(res,l+r-2);  return max(l,r);  }  int diameterOfBinaryTree(TreeNode* root) {  dfs(root);  return res;  } };   617、合并二叉树 1 2 3 4 5 6 7 8 9 10 11  class Solution { public:  TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {  if(root1==nullptr){return root2;}  if(root2==nullptr){return root1;}  root2-\u0026gt;val=root2-\u0026gt;val+root1-\u0026gt;val;  root2-\u0026gt;left=mergeTrees(root1-\u0026gt;left,root2-\u0026gt;left);  root2-\u0026gt;right=mergeTrees(root1-\u0026gt;right,root2-\u0026gt;right);  return root2;  } };   中等模块 2、两数相加 3、无重复字符串的最长子串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public:  int lengthOfLongestSubstring(string s) {  int n = s.length();  if(n==0) return 0;  int left=0;  int len = 0;  int res = 0;  unordered_map\u0026lt;char,int\u0026gt; st;  for(int i =0;i\u0026lt;n;i++){  if(!st.count(s[i])){  len++;  st[s[i]]=i;  }else{  left=st[s[i]]\u0026gt;=left?st[s[i]]+1:left; //注意  len = i-left+1;  st[s[i]]=i;  }  res=max(res,len);  }  return res;  } };   5、最长回文子串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public:  string longestPalindrome(string s) {  int n = s.length();  int maxLen = 0;  int maxLeft = 0;  int len = 1;  for(int i =0;i\u0026lt;n;i++){  int l = i-1;  int r = i+1;  while(l\u0026gt;=0\u0026amp;\u0026amp;s[l]==s[i]){  len++;  l--;  }  while(r\u0026lt;n\u0026amp;\u0026amp;s[r]==s[i]){  len++;  r++;  }  while(l\u0026gt;=0\u0026amp;\u0026amp;r\u0026lt;n\u0026amp;\u0026amp;s[l]==s[r]){  len=len+2;  l--;  r++;  }  if(len\u0026gt;maxLen){  maxLen=len;  maxLeft=l;  }  len = 1;  }  return s.substr(maxLeft+1,maxLen);  } };   11、盛最多水的容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public:  int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) {  int r = height.size()-1;  int res = 0;  int l = 0;  int sum =0;  while(l\u0026lt;r){  int shorter = min(height[l],height[r]);  int len = r-l;  if(height[l]\u0026lt;height[r]){  l++;  }else{  r--;  }  sum=shorter*len;  res=max(res,sum);  }  return res;  } };   15、三数之和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans;  if(nums.size()\u0026lt;3) return ans;  sort(nums.begin(), nums.end());  if(nums[0]\u0026gt;0) return ans;  int i = 0;  while(i\u0026lt;nums.size()){  if(nums[i]\u0026gt;0) break; // 1楼网友指正，将这个if语句放这里提前终止循环  int left = i+1, right = nums.size()-1;  while(left\u0026lt; right){  if(nums[i] + nums[left] +nums[right]\u0026gt;0)  right--;  else if(nums[i] + nums[left] +nums[right]\u0026lt;0)  left++;  else{  ans.push_back({nums[i], nums[left], nums[right]});  // 相同的left和right不应该再次出现，因此跳过  while(left\u0026lt;right\u0026amp;\u0026amp;nums[left]==nums[left+1])  left++;  while(left\u0026lt;right\u0026amp;\u0026amp;nums[right] == nums[right-1])  right--;  left++;  right--;  }  }  // 避免nums[i]作为第一个数重复出现  while(i+1\u0026lt;nums.size()\u0026amp;\u0026amp;nums[i] == nums[i+1])  i++;  i++;  }  return ans;  } };   16、最接近的三数之和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public:  int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) {  int res = 1e7;  int n = nums.size();  sort(nums.begin(),nums.end());  int i =0;  while(i\u0026lt;n){  int l = i+1;  int r = n-1;  while(l\u0026lt;r){  int sum=nums[i]+nums[l]+nums[r];  if(sum\u0026lt;target){  l++;  if(abs(res-target)\u0026gt;abs(sum-target)){  res=sum;  }  }else if(sum\u0026gt;target){  r--;  if(abs(res-target)\u0026gt;abs(sum-target)){  res=sum;  }  }  else{  return target;  }  }  i++;  }  return res;  } };   17、电话号码的字母组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution { public:  //1. 用map记录每个数字按键对应的所有字母  unordered_map\u0026lt;char, string\u0026gt; m = {  {\u0026#39;2\u0026#39;, \u0026#34;abc\u0026#34;}, {\u0026#39;3\u0026#39;, \u0026#34;def\u0026#34;}, {\u0026#39;4\u0026#39;, \u0026#34;ghi\u0026#34;}, {\u0026#39;5\u0026#39;, \u0026#34;jkl\u0026#34;}, {\u0026#39;6\u0026#39;, \u0026#34;mno\u0026#34;},  {\u0026#39;7\u0026#39;, \u0026#34;pqrs\u0026#34;}, {\u0026#39;8\u0026#39;, \u0026#34;tuv\u0026#34;}, {\u0026#39;9\u0026#39;, \u0026#34;wxyz\u0026#34;}  };  //2. 存储最终结果和临时结果的变量  vector\u0026lt;string\u0026gt; ans;  string current;  string cp;  int n;  void dfs(int len,char c){  if(current.length()==n){  ans.push_back(current);  return;  }  for(int i =0;i\u0026lt;m[c].length();i++){  current+=m[c][i];  dfs(len+1,cp[len+1]);  current.pop_back();  }  }  vector\u0026lt;string\u0026gt; letterCombinations(string digits) {  cp = digits;  n = digits.length();  if(n==0) return ans;  dfs(0,digits[0]);  return ans;  } };   19、删除链表的倒数第N个结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public:  ListNode* removeNthFromEnd(ListNode* head, int n) {  ListNode* start = head;  ListNode* end = head;  while(n--){  end = end -\u0026gt; next;  }  if(end == nullptr) return head-\u0026gt;next;  while(end -\u0026gt; next != nullptr){  end = end -\u0026gt; next;  start = start -\u0026gt; next;  }  start -\u0026gt; next = start -\u0026gt; next -\u0026gt; next;  return head;  } };   22、括号生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  class Solution { public:  vector\u0026lt;string\u0026gt; res;  string cur=\u0026#34;\u0026#34;;  void dfs(int l,int r){  if(l==0\u0026amp;\u0026amp;r==0){  res.push_back(cur);  return;  }  if(l\u0026gt;0){  cur+=\u0026#39;(\u0026#39;;  dfs(l-1,r);  cur.pop_back();  }  if(r\u0026gt;l){  cur+=\u0026#39;)\u0026#39;;  dfs(l,r-1);  cur.pop_back();  }  }  vector\u0026lt;string\u0026gt; generateParenthesis(int n) {  dfs(n,n);  return res;  } };   class Solution { public:  int m;  vector\u0026lt;string\u0026gt; res;  string cur=\u0026#34;\u0026#34;;  void dfs(int l,int r){  if(l==r\u0026amp;\u0026amp;l+r==2*m){  res.push_back(cur);  return;  }  if(l\u0026lt;=m){  cur+=\u0026#39;(\u0026#39;;  dfs(l+1,r);  cur.pop_back();  }  if(l\u0026gt;r){  cur+=\u0026#39;)\u0026#39;;  dfs(l,r+1);  cur.pop_back();  }  }  vector\u0026lt;string\u0026gt; generateParenthesis(int n) {  m = n;  dfs(0,0);  return res;  } };   31、下一个排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution { public:  void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  next_permutation(nums.begin(),nums.end());  } };  class Solution { public:  void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int n = nums.size();  int i,j;  bool flag=false;  for(int k=n-1;k\u0026gt;=1;k--){  if(nums[k]\u0026gt;nums[k-1]){  i = k-1;  j = k;  flag=true;  break;  }  }  if(flag){  for(int k = n-1;k\u0026gt;=i;k--){  if(nums[k]\u0026gt;nums[i]){  swap(nums[k],nums[i]);  sort(nums.begin()+j,nums.end());  break;  }  }  }  else sort(nums.begin(),nums.end());  } };   ","permalink":"https://kevinerr.github.io/posts/algorithm/leetcode_hot100/","summary":"简单模块 1、两数之和 简单题，用unordered_map\u0026lt;int,int\u0026gt; um;key为值，value为数组下标 遍历一遍，看um","title":"Leetcode_hot100"},{"content":"vector 初始化 1 2 3 4  vector\u0026lt;int\u0026gt; a(10); //没有给出初值，其值是不确定的 vector\u0026lt;int\u0026gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1 vector\u0026lt;int\u0026gt; a(b); //用b向量来创建a向量，整体复制性赋值 int b[7]={1,2,3,4,5,9,8}; vector\u0026lt;int\u0026gt; a(b,b+7); //从数组中获得初值   常用操作 1 2 3 4 5 6  a.back(); //返回a的最后一个元素 a.front(); //返回a的第一个元素 a.pop_back(); //删除a向量的最后一个元素 a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5 a.size(); //返回a中元素的个数； a.clear(); //清空a中的元素   重要算法 1 2 3  sort(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列 reverse(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置， find(a.begin(),a.end(),10); //在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置   误区 1 2 3 4  vector\u0026lt;int\u0026gt; a; for(int i=0;i\u0026lt;10;i++)  a[i]=i; //这种做法以及类似的做法都是错误的。下标只能用于获取已存在的元素，而现在的a[i]还是空的对象   pair 定义 1 2 3  pair\u0026lt;T1, T2\u0026gt; p1; //创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。 p1.first; // 返回对象p1中名为first的公有数据成员 p1.second; // 返回对象p1中名为second的公有数据成员   string 初始化 1 2  string s1; //默认值是\u0026#34;\u0026#34; string s4 (5, \u0026#39;s\u0026#39;); //\u0026#34;sssss\u0026#34;   string 字符串的增删改查 1 2 3 4  s1 = s2 = \u0026#34;1234567890\u0026#34;; s3 = \u0026#34;aaa\u0026#34;; s1.insert(5, s3); //12345aaa67890 //pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串   1 2 3 4  string s1, s2, s3; s1 = s2 = s3 = \u0026#34;1234567890\u0026#34;; s2.erase(5); //12345 s3.erase(5, 3); //1234590 3表示len   1 2 3  string s1 = \u0026#34;first second third\u0026#34;; string s2; s2 = s1.substr(6, 6); //second 6表示len   1 2 3 4 5 6 7 8  string s1 = \u0026#34;first second second third\u0026#34;; string s2 = \u0026#34;c\u0026#34;; s1.find(s2); //8 s1.find(s2,10); //15 从第十个位置开始找 s1.rfind(s2); //15 //从右边开始找 s1.find(s2,10); //8  返回的值都是数组下标   stack 常用操作\n1 2 3 4 5 6 7  stack\u0026lt;int\u0026gt; q;\t//以int型为例 int x; q.push(x);\t//将x压入栈顶 q.top();\t//返回栈顶的元素 q.pop();\t//删除栈顶的元素 q.size();\t//返回栈中元素的个数 q.empty();\t//检查栈是否为空,若为空返回true,否则返回false   queue 常用操作\n1 2 3 4 5 6 7 8  queue\u0026lt;int\u0026gt; q;\t//以int型为例 int x; q.push(x);\t//在末尾加入一个元素 q.pop();\t//删除第一个元素 q.front();\t//返回第一个元素 q.back();\t//返回最后一个元素 q.size();\t//返回队列中元素的个数 q.empty();\t//如果队列空则返回真   priority_queue 在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。它本质是一个堆实现的。\n定义：priority_queue\u0026lt;Type, Container, Functional\u0026gt;\nType 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。\n当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。\n大根堆 大到小 用less\n1 2 3 4 5 6 7 8 9 10 11 12  //升序队列，小顶堆 priority_queue \u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt; \u0026gt; q; 0 1 2 3 4 //降序队列，大顶堆,默认 priority_queue \u0026lt;int,vector\u0026lt;int\u0026gt;,less\u0026lt;int\u0026gt; \u0026gt;q; 4 3 2 1 0 基本操作 top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容   规则：pair的比较，先比较第一个元素，第一个相等比较第二个。\n1  priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; a;   deque 1 2 3 4 5 6 7  deque\u0026lt;int\u0026gt; d1; d1.push_back(10);//在容器尾部添加一个数据 d1.push_front(30);//在容器头部添加一个数据 d1.pop_back(); /* 删除最后的元素 */ d1.pop_front(); /* 删除最前面的元素 */ front();//返回第一个数据。 back();//返回最后一个数据   map unordered_map 相当于HashMap\nmap相当于java中的TreeMap\nunordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储（用红黑树实现）\n1 2 3 4 5 6  size 返回有效元素个数 insert 插入元素 erase　删除元素 count 返回匹配给定主键的元素的个数 for (auto x: map)  cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl;   set unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会\n1 容量函数 容器大小：st.size(); 容器判空：st.empty(); 查找键 key 的元素个数：st.count(key);\n2 添加函数 在容器中插入元素：st.insert(const T\u0026amp; x); 任意位置插入一个元素：st.insert(iterator it, const T\u0026amp; x);\n3 删除函数 删除容器中值为 elem 的元素：st.pop_back(const T\u0026amp; elem); 删除it迭代器所指的元素：st.erase(iterator it); 清空所有元素：st.clear();\n4 访问函数 st.find(key); 查找键 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()\n1  st.find(s[i]) != st.end() //判断set中是否含有某元素   ","permalink":"https://kevinerr.github.io/posts/algorithm/stl/","summary":"vector 初始化 1 2 3 4 vector\u0026lt;int\u0026gt; a(10); //没有给出初值，其值是不确定的 vector\u0026lt;int\u0026gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1 vector\u0026lt;int\u0026gt; a(b); //用b向量来创建a向量","title":"Stl"},{"content":"简介 Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。\n三大功能 反向代理 负载均衡 动静分离 高可用集群 主从复制 双主模式\nkeepalived ","permalink":"https://kevinerr.github.io/posts/tech/nginx/","summary":"简介 Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。 三大功能 反向代理 负","title":"nginx"},{"content":"四种变量声明 const和iota 多返回值 init函数 import导包 指针 defer 数组/动态数组 ","permalink":"https://kevinerr.github.io/posts/tech/go%E6%95%99%E7%A8%8B/","summary":"四种变量声明 const和iota 多返回值 init函数 import导包 指针 defer 数组/动态数组","title":"go教程"},{"content":"docker官方文档 https://zhuanlan.zhihu.com/p/187505981\ndocker安装  卸载旧版本  1 2 3 4 5 6 7 8  sudo yum remove docker \\  docker-client \\  docker-client-latest \\  docker-common \\  docker-latest \\  docker-latest-logrotate \\  docker-logrotate \\  docker-engine   2.安装yum-utils\n1  sudo yum install -y yum-utils   3.为yum源添加docker仓库位置\n1  sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo   4.安装docker服务\n1  sudo yum install docker-ce docker-ce-cli containerd.io   5.启动docker服务并测试\n1 2  systemctl start docker docker version   镜像命令   搜索镜像\n1  docker search mysql --filter=STARS=5000 #过滤标星大于5000的镜像     下载镜像\n1  docker pull java:8 #镜像名称：镜像版本号     查看镜像\n1 2 3  docker images -a #列出所有镜像 docker images -q #只列出镜像的ID docker images -aq     删除镜像\n1 2 3  docker rmi java:8 #指定名称删除镜像(也可以通过id伤删除) docker rmi -f java:8 #指定名称删除镜像（强制） docker rmi -f $(docker images -aq) #删除所有镜像     发布镜像\n1 2 3 4 5 6  # 登录Docker Hub docker login # 给本地镜像打标签为远程仓库名称 docker tag mall/mall-admin:1.0-SNAPSHOT macrodocker/mall-admin:1.0-SNAPSHOT # 推送到远程仓库 docker push macrodocker/mall-admin:1.0-SNAPSHOT     压缩解压\n1 2 3 4  # 压缩 docker save # 解压 docker load     容器命令   新建并启动容器\n1 2 3  docker run -d --name nginx01 -p 3344:80 nginx docker run -it nginx /bin/bash docker run -d nginx #会自动停止     -p：将宿主机和容器端口进行映射，格式为：宿主机端口:容器端口；\n  \u0026ndash;name：指定容器名称，之后可以通过容器名称来操作容器；\n  -d：后台方式启动\n  -it：交互式方式启动，进入容器查看内容(ls,exit)\n  1 2  exit #容器停止并退出 CTRL+p+q #容器不停止退出       查看容器\n1 2 3  docker ps #列出运行中的容器 docker ps -a #列出所有容器 docker ps -q #只列出容器的ID     删除容器\n1 2  docker rm nginx #删除指定容器 docker rm -f $(docker ps -aq) #删除所有镜像     启动和停止容器\n1 2 3 4  docker start nginx docker restart nginx docker stop nginx docker kill nginx     查看容器的日志\n1 2  docker logs nginx #查看容器产生的全部日志 docker logs -f -t --tail 10 nginx #前十条     查看容器进程信息\n1  docker top nginx     查看容器元数据\n1 2  docker inspect nginx docker inspect --format \u0026#39;{{ .NetworkSettings.IPAddress }}\u0026#39; nginx #查看容器的IP地址     进入当前正在运行的容器\n1 2  docker exec -it nginx /bin/bash #进入容器开启新的终端 docker attach nginx #进入容器正在执行当前的代码     从容器内拷贝文件到主机上\n1 2 3  docker cp 容器id:容器内路径 目的主机路径 docker cp nginx:/home/hello.java /home touch hello.java #创建一个空的java文件     docker安装nginx   搜索并下载镜像\n1 2 3 4 5 6 7 8 9  search pull docker run -d --name nginx01 -p 3344:80 nginx docker ps curl localhost:3344 docker exec -it nginx01 /bin/bash whereis nginx cd /etc/nginx ls #可以发现nginx.conf文件   每次改动nginx.conf都需要进入容器内部？ 数据卷技术\n1 2 3  docker run -d --name tomcat02 -p 3355:8080 tomcat docker exec -it tomcat02 /bin/bash cp -r webapps.dist/* webapps #没有webapps。阿里云镜像的原因，默认是最小的镜像   1 2 3 4 5  docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; elasticsearch:7.6.2 #会自动退出  docker run -dit --name elasticsearch -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; elasticsearch:7.6.2 /bin/bash clear curl localhost:9200     可视化 portainer\n镜像原理 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。它包含运行某个环境所需的所有内容，包括代码、库、环境变量和配置文件。\n联合文件系统（UnionFS） 1、联合文件系统是docker镜像的基础，是一种分层的、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层叠加。\n2、联合文件系统的特点：一次同时加载多个文件系统，但是从外观来看，只能看到一个文件系统。联合加载会把各层的文件系统叠加起来，这样最终的文件系统会包含所有的目录和文件。\n3、docker进行可以通过分层来继承，基于基础镜像，可以制作各种具体的应用镜像。\n镜像加载原理 1、docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统是联合文件系统\n2、docker自底向上由两个层级构成：bootfs和rootfs。\n3、bootfs（boot file system）是docker镜像的最底层，主要包含bootloader和kernel，相当于linux内核加载器和linux内核。bootfs加载完成后内存使用权交给内核，此时系统会卸载bootfs。\n4、rootfs（root file system）就是各种不同的linux操作系统发行版，比如ubuntu和centos。在rootfs之上，是典型linux系统中的/dev，/etc，/bin等目录和文件。rootfs可以很小，共用宿主机的内核即可。\n5、镜像为什么采取分层结构：为了共享资源。有多个镜像都从相同的base镜像构建而来，那么宿主机只要在磁盘上保存一份base镜像，同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。\n镜像的特点 1、docker镜像都是只读的。\n-2、当一个容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常叫做“容器层”，“容器层”之下的都叫做“镜像层”。\ncommit镜像 1 2  docker commit -a=\u0026#34;kevin\u0026#34; -m=\u0026#34;add webapps\u0026#34; 镜像id tomcat02:1.0 docker commit -a=\u0026#34;作者\u0026#34; -m=\u0026#34;提交的描述信息\u0026#34; 镜像id 目标镜像名:[TAG]   相当于学习vm时的一个快照\n容器数据卷 数据持久化\ndocker容器中产生的数据同步到本地\n这就是卷技术！将容器的目录挂载到Linux上！\n容器的持久化和同步操作！容器间也是可以数据共享的！双向绑定\n1 2 3 4  docker run -it -v 主机目录:容器目录 centos /bin/bash touch test.java vim test.java cat test.java   实战mysql 1 2 3 4 5 6  docker run -d -p 3310:3306 --name mysql01 \\ -v /mydata/mysql/log:/var/log/mysql \\ -v /mydata/mysql/data:/var/lib/mysql \\ -v /mydata/mysql/conf:/etc/mysql \\ -e MYSQL_ROOT_PASSWORD=hkh0 \\ -d mysql:5.7   navicat 链接服务器的3310 和容器内的3306映射，就可以连接上了！\n假设我们将容器删除，挂载到本地的数据卷依旧不会丢失\n挂载类型 1 2 3 4  -v 容器内路径 #匿名挂载 -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 docker volume inspect juming-mysql #可以查看到没有指定目录的情况下一般是在 /var/lib/docker/volumes/xxx/_data   1 2 3  docker run -d -p 3310:3306 -v juming-mysql:/var/log/mysql:ro mysql ro #只读，说明这个路径只能通过宿主机来操作，容器内无法操作 rw   数据卷容器 多个mysql同步数据\n两个或多个容器之间实现数据共享\n1  docker run -it --name docker02 --volumes-from docker01 centos   容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止\nDockerFile 1 2 3 4 5 6 7 8 9  vim dockerfile1 #创建一个dockerfile文件   #文件中的内容 FROM centos VOLUME [\u0026#34;volume01\u0026#34;,\u0026#34;volume02\u0026#34;] CMD echo \u0026#34;----end---\u0026#34; CMD /bin/bash #这里的每个命令都是镜像的一层   1 2 3  docker build -f dockerfile1 -t kevin/centos . #构建镜像 docker run #运行镜像 docker push #发布镜像   总结 Docker网络 1 2 3 4  ip addr lo 本机回环地址 eth0 阿里云内网地址 docker0 docker0地址   docker是如何处理容器网络访问的\n1 2 3 4 5 6 7 8 9 10  docker exec -it tomcat ip addr #得到eth0@if67地址的ip地址,docker分配的 ping 172.17.0.7 #linux能够ping通docker docker exec -it tomcat02 ping 172.17.0.7 #容器能ping通容器 #是否可以使用名字来访问容器 docker exec -it tomcat02 ping tomcat01 #ping不通 docker exec -d -P --name tomcat03 --link tomcat02 tomcat docker exec -it tomcat03 ping tomcat02 #这时候就能连通 docker exec -it tomcat02 ping tomcat03 #反向不一定能连通 docker network inspect 容器id docker exec -it tomcat03 cat /etc/hosts #可以直接看到tomcat02和IP地址绑定了   docker使用的是linux的桥接模式，使用的技术是evth-pair（openstack，ovs的连接都是使用此技术，一对虚拟设备接口，他们是成对出现的，一段连着协议，一段彼此相连，evth-pair 就像一个桥梁，连接各种虚拟网络设备）技术！网卡是一对一对的\n自定义网络 1 2 3 4 5 6 7  docker network ls # docker network create --driver bridge：桥接模式 --subnet：子网 --gateway：网关 mynet：网络名 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet docker network inspect mynet #查看自定义网络信息 docker run -d -P --name tomcat01-net --net mynet tomcat docker run -d -P --name tomcat02-net --net mynet tomcat docker exec -it tomcat01-net ping tomcat02-net #可以连通！   bridge：桥接模式（docker默认） host：和宿主机共享网络 none：不配置网络 我们上面启动容器通过 docker run -d -P \u0026ndash;name tomcat01 tomcat 启动的，实际上docker默认为 docker run -d -P \u0026ndash;name tomcat01 \u0026ndash;net bridge tomcat，容器之间不能通过域名访问，只能使用 \u0026ndash;link打通，这里我们自定义网络！\n网络连通 1 2  # 将docker0下的tomcat01连接到mynet网卡上 docker network connect mynet tomcat01   连通之后，tomcat01直接加到了mynet网络下，一个容器就拥有两个IP地址\n企业实战 Docker Compose 前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知 使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具\n工程、服务、容器 Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container） Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例\nDocker Swarm Swarm 是目前 Docker 官方唯一指定（绑定）的集群管理工具。Docker 1.12 内嵌了 swarm mode 集群管理模式。\ndocker swarm：集群管理，子命令有 init, join,join-token, leave, update docker node：节点管理，子命令有 demote, inspect,ls, promote, rm, ps, update docker service：服务管理，子命令有 create, inspect, ps, ls ,rm , scale, update docker stack/deploy：试验特性，用于多应用部署，等正式版加进来再说。\nCI/CD Jenkins 流水线！ ","permalink":"https://kevinerr.github.io/posts/tech/docker/","summary":"docker官方文档 https://zhuanlan.zhihu.com/p/187505981 docker安装 卸载旧版本 1 2 3 4 5 6 7 8 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2.安装yum-utils 1 sudo yum install -y yum-utils 3","title":"docker"},{"content":"SpringMVC SpringMVC核心组件 SpringMVC工作流程 开发流程 视图解析器前缀后缀写反了\nRequestMapping Cookie ","permalink":"https://kevinerr.github.io/posts/tech/springmvc/","summary":"SpringMVC SpringMVC核心组件 SpringMVC工作流程 开发流程 视图解析器前缀后缀写反了 RequestMapping Cookie","title":"springmvc"},{"content":"Servlet Tomcat 定义 servlet的生命周期 ServletConfig/ServletContext servlet的层次结构 JSP 定义 JSP嵌入java的三种方式 JSP9个内置对象 request常用方法 重定向和转发 session Cookie Cookie和session Filter过滤器 Filter的生命周期 Filter的应用场景 文件上传下载 上传 Ajax Ajax vs 传统 原理 应用 JSON JDBC JDBC体系结构 使用 SQL注入 数据库连接池 ","permalink":"https://kevinerr.github.io/posts/tech/javaweb/","summary":"Servlet Tomcat 定义 servlet的生命周期 ServletConfig/ServletContext servlet的层次结构 JSP 定义 JSP嵌入java的三种方式 JSP9个内置对象 request常用方法 重定向和","title":"javaweb"},{"content":"自增变量 单例模式 类初始化和实例初始化（子类的重写 方法参数的传递机制 递归与循环迭代 成员变量/局部变量 Spring Bean的作用域 Spring支持的常用数据库事务传播行为和隔离级别 SpringMVC解决POST/Get表格请求中文乱码问题\nPOST：web.xml中配置CharacterEncodingFilter中encoding设为utf-8；\nGet：tomcat8已解决，7：server.xml中Connector加上这个\n简单的谈一下SpringMVC的工作流程 MyBatis中当实体类中的属性名和表中的字段名不同时 1、写sql语句时起别名\nLinux常用服务类相关命令 git分支相关命令\nRedis持久化 Mysql什么时候建立索引 JVM垃圾回收机制 Redis数据类型在项目中的使用场景 es和solr的区别 单点登录 购物车 消息队列 ","permalink":"https://kevinerr.github.io/posts/tech/java%E7%AC%94%E8%AF%95/","summary":"自增变量 单例模式 类初始化和实例初始化（子类的重写 方法参数的传递机制 递归与循环迭代 成员变量/局部变量 Spring Bean的作用域 Spring支持的常用数","title":"java笔试"},{"content":"MyBatis的工作原理 Mybatis 缓存 ","permalink":"https://kevinerr.github.io/posts/tech/mybatis/","summary":"MyBatis的工作原理 Mybatis 缓存","title":"mybatis"},{"content":"什么是中间件 中间件（Middleware）是处于操作系统和应用程序之间的软件，人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台。中间件屏蔽了底层操作系统的复杂性\n 消息中间件 (ActiveMQ/RabbitMQ/Kafaka/RocketMQ) 负载均衡中间件(Nginx/Lvs/CDN) 缓存中间件(Memcache/Redis) 数据库中间件(ShardingJdbc/Mycat)  为什么需要中间件 早期单体架构（耦合度太高，运维的成本过高，升级架构的复杂度也会增大）\n分布式架构（就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成）技术栈的选择可以变的灵活、弹性的部署、以合理的分配服务资源，不造成服务器资源的浪费、系统的独立维护和部署，耦合度降低，可插拔性\n但也不要盲目选择分布式架构（面临的错误和容错性也会成倍增加、占用的服务器端口和通讯的选择的成本高）\n什么是消息中间件 异步、解耦、削峰\n本质：它是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。\n1:跨系统数据传递 2:高并发的流量削峰 3:数据的分发和异步处理 4:大数据分析与传递 5:分布式事务\n比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10W的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行。\n消息中间件的核心部分 消息的协议 我们知道消息中间件负责数据的传递，存储，和分发消费三个部分，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IP，UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为：协议。\n面试题：为什么消息中间件不直接使用http协议呢？ 1: 因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。 2:大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。\nAMQP协议(全称：Advanced Message Queuing Protocol) 是高级消息队列协议，基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等（1：分布式事务支持。2：消息的持久化支持。3：高性能和高可靠的消息处理优势。）\nMQTT协议：（Message Queueing Telemetry Transport）消息队列是IBM开放的一个即时通讯协议，物联网系统架构中的重要组成部分。\n持久化机制 简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。\n消息的分发策略 MQ消息队列有如下几个角色 1：生产者 2：存储消息 3：消费者\n推拉机制\n    ActiveMQ RabbitMQ Kafka RocketMQ     发布订阅 支持 支持 支持 支持   轮询分发 支持 支持 支持 /   公平分发 / 支持 支持 /   重发 支持 支持 / 支持   消息拉取 / 支持 支持 支持    高可用，高可靠 所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力。 当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU,内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署。来达到高可用的目的。\n所谓高可用是指：是指系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。\n集群模式1 - Master-slave主从共享数据的部署方式\n集群模式2 - Master- slave主从同步部署方式\n集群模式3 - 多主集群同步部署模式\n集群模式4 - 多主集群转发部署模式\n集群模式5 -Master-slave与Breoker-cluster组合的方案\n","permalink":"https://kevinerr.github.io/posts/tech/%E4%B8%AD%E9%97%B4%E4%BB%B6/","summary":"什么是中间件 中间件（Middleware）是处于操作系统和应用程序之间的软件，人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台。","title":"中间件"},{"content":"ElasticSearch Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎\n安装环境 1 2 3 4  ElasticSearch: https://mirrors.huaweicloud.com/elasticsearch/?C=N\u0026amp;O=D logstash: https://mirrors.huaweicloud.com/logstash/?C=N\u0026amp;O=D kibana: https://mirrors.huaweicloud.com/kibana/?C=N\u0026amp;O=D ik分词器：https://github.com/medcl/elasticsearch-analysis-ik/releases   跨域 在elasticsearch.yml文件下添加\n1 2  http.cors.enabled: true http.cors.allow-origin: \u0026#34;*\u0026#34;   IK分词器 1 2 3 4 5 6 7 8 9 10 11  GET _analyze {  \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;,  \u0026#34;text\u0026#34;: \u0026#34;贺凯恒\u0026#34; }  GET _analyze {  \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;,  \u0026#34;text\u0026#34;: \u0026#34;贺凯恒\u0026#34; }   ik_smart 最少切分\nik_max_word 最细粒度划分！穷尽词库的可能\n*配置自己的分词器\nIKAnalyzer.cfg.xml dic文档\nES核心概念 （1）：Near Relatime: 近实时，两个意思：从写入数据到可以被搜索有一个小延迟（大概一秒）；基于es搜索和分析可以达到秒级。\n（2）：Cluster: 集群，包含多个节点，每个节点属于哪一个集群是通过配置（集群名称，默认是elasticsearch）来决定的。对于小型应用来说，刚开始一个集群就一个节点很正常。\n（3）： Node:节点。集群当中的一个节点，节点也有一个名称，默认是随机分配的，节点名称很重要（在执行运维管理操作的时候），默认节点会加入到一个名为“elasticsearch”的集群。如果直接启动一堆节点，默认会加入名为elasticsearch的集群。\n（4）： Document\u0026amp;field: 文档：es当中的最小单元，一个document可以是一条商品数据，也可以是一条订单数据，通常用JSON数据结构表示，每个index下的type当中，都可以去存储多个document，一个document中可以有多个field，field就是一个数据字段。\n（5）：index: 索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document，比如说一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品的document。\n（6）：type：类型：每个索引当中都可以有一个type或者多个type，type是index的一个逻辑数据分类。一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户type，博客type，评论type等等。\n（7）：shard: 单台机器无法存储大量的数据，es可以将一个索引当中的数据切分为多个shard，分布在多台机器上存储，有了shard就可以横向扩展，存储更多的数据，让搜索和分析等操作分布在多台机器上去执行，提升吞吐量和性能，每个shard都是一个Lucene index。\n（8）：replica: 任何一个服务器随时都有可能宕机或者故障，此时shard就有可能丢失，因此可以为每个shard创建多个replica副本，replica可以在shard故障时提供备用服务，以保证数据不会丢失，多个replica可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，每个shard默认一个）。默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台机器。\nES与数据库对比    Elasticsearch 数据库     Document 行   Type 表   Index 库    精髓 反向索引又叫倒排索引，是根据文章内容中的关键字建立索引。 搜索引擎原理就是建立反向索引。 Elasticsearch 在 Lucene 的基础上进行封装，实现了分布式搜索引擎。 Elasticsearch 中的索引、类型和文档的概念比较重要，类似于 MySQL 中的数据库、表和行。 Elasticsearch 也是 Master-slave 架构，也实现了数据的分片和备份。 Elasticsearch 一个典型应用就是 ELK 日志分析系统。\n","permalink":"https://kevinerr.github.io/posts/tech/elasticsearch/","summary":"ElasticSearch Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎 安装环境 1 2 3 4 ElasticSearch: https://mirrors.huaweicloud.com/elasticsearch/?C=N\u0026amp;O=D logstash: https://mirrors.huaweicloud.com/logstash/?C=N\u0026amp;O=D kibana: https://mirrors.huaweicloud.com/kibana/?C=N\u0026amp;O=D ik分词器：https://github.com/med","title":"ElasticSearch"},{"content":"正版office 官网 使用方法\n激活windows 以管理员身份运行cmd slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato\n重装系统 下载window10镜像 安装pe系统 进入BIOS\nkxsw   购买服务器：购买日本的服务器 快速体验项目：ssh工具连接服务器 快速体验项目：安装 V2Ray bash \u0026lt;(curl -s -L https://git.io/v2ray.sh) 保存V2Ray配置信息 快速体验项目：开启端口 28500 uuid:87037fce-3b15-4a06-bc30-6ab5040dba0b sudo firewall-cmd \u0026ndash;zone=public \u0026ndash;add-port=28500/tcp \u0026ndash;permanent firewall-cmd \u0026ndash;reload 快速体验项目：下载v2rayN-Core.zip 快速体验项目：使用V2Ray客户端添加Vmess服务器 测试 快速体验项目：每次使用结束后删除实例并使用快照恢复 快照恢复后使用systemctl start v2ray    netstat -ano\nnetstat -ano|findstr \u0026ldquo;8080\u0026rdquo;\ntasklist|findstr \u0026ldquo;8696\u0026rdquo;\n​\n","permalink":"https://kevinerr.github.io/posts/life/%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E5%B0%8Ftips/","summary":"正版office 官网 使用方法 激活windows 以管理员身份运行cmd slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato 重装系统 下载window10镜像 安装pe系统 进入BIOS","title":"非常有用的小tips"},{"content":"工具面板 文字T键入——放大镜（Alt切换）——抓手（移动画布）；Ctrl+0以最大呈现 新建工作区：导航器，画笔，字符\n图层面板 混合模式：滤色（滤去深色） 文字立体感：可投影（图层样式）\n图片裁剪 图像→画布大小【需要先解除锁定】：Ctrl+T【自动变换工具】选中图片，shift等比例缩放，Alt中心缩放\n蒙版【图片合成】：不破坏原始素材进行修改 拖动→添加蒙版（细微修改：流量、不透明度）→画笔（黑透白不透）\n校色 新建调整图层→曲线（调节明暗）、色彩平衡 【只影响下一张图片：创建剪切图层】\n钢笔工具【抠图：不用选区和蒙版（蒙版抠图柔和不精确）】 好习惯：Ctrl+J复制图层→隐藏 曲线：按住左键←直线（Alt：转换点工具/一侧变换点击一端点） Ctrl：改变锚点位置 增加锚点：点击两点之间 减少锚点：点击一点 系统新建形状→Ctrl+Z退回，惦记着最后一个点连接\n修片： ①修复红眼：使用红眼修复工具（需选中整个眼睛） ②污渍修复工具：可小地方修修改→就近取色 ③修复画笔工具：Alt+拾色（可任取色，且过渡更自然） ④仿制图章：Alt+拾色（任取色，过渡相对不是和和谐） ⑤修补工具→去水印\n文字：选“平滑”消除锯齿，调整字体和间距 【制作光晕】：使用智能对象（智能对象：可无限期修改） 新建图层→填充前景黑色→滤镜/渲染/光线 混合模式：【滤色】 裁剪：【先修改比例等默认值】 画笔工具：【→缩小，】→放大（在英文非大写状态） 【分开调色】：建立组（必须勾选此组有效） 【剪影】：使用钢笔选中建立选区使用蒙板纯色填充之后→复制→在第一个图层添加图层样式“色彩叠加”→移动→→使用【渐变映射整体调整】​\n","permalink":"https://kevinerr.github.io/posts/life/ps/","summary":"工具面板 文字T键入——放大镜（Alt切换）——抓手（移动画布）；Ctrl+0以最大呈现 新建工作区：导航器，画笔，字符 图层面板 混合模式：滤色（","title":"ps"},{"content":"找出数组中重复的元素 n个数（每个数的取值范围是1到n-1） https://www.acwing.com/solution/content/707/ 把每个数放到它原本的位置上去O(n),O(1),数组发生了改变\nhttps://www.acwing.com/solution/content/693/ 抽屉原理二分法，O(nlogn),O(1),数组没发生了改变\n计数数组 O(n),O(n),数组没发生改变\n只有1个数只出现了一次，其余的数都出现了2次 异或\n只有1个数只出现了一次，其余的数都出现了2次 先异或所有的，得到的结果就是x^y,因为它不等于0，所以二进制数一定有1位为1，设这一位数为k\n而x、y在这位数上一定不同，把这位数上为1的分为一类，这一类中包含x或y的一个，异或这一类得出x\n再x^x^y=y\n在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。 🗡☞offer https://blog.csdn.net/qq_30277239/category_8713779_2.html\n算法提高课 https://blog.csdn.net/qq_30277239/category_9672147_2.html\n大厂笔试 网易2021\nhttps://www.nowcoder.com/questionTerminal/592a069811044d3fadb94c6c55d7b4f2\nComparable和Comparator区别是什么？\nhttp/2相比http/1.1有什么新特性？\nSTL map 红黑树\n在map内部所有的数据都是有序的\n1 2 3 4 5 6  map\u0026lt;int,int\u0026gt; m1; for(auto x:m1){  if(x.second==1){  cout\u0026lt;\u0026lt;m2[x.first]\u0026lt;\u0026lt;endl;  } }   DP https://www.acwing.coml/blog/content/7459/\nhttps://oi-wiki.org/string/trie/\nhttps://space.bilibili.com/517494241?spm_id_from=333.788.b_765f7570696e666f.2\n上下左右走 最长上升子序列模型 背包模型 状态机模型 连通性状态压缩dp 集合类状态压缩 区间dp 树形dp 数位dp 单调队列优化dp 斜率优化dp 搜索 Flood Fill https://blog.csdn.net/weixin_42979819/article/details/104020930 https://blog.csdn.net/weixin_42638946/article/details/114854833\nBFS综合 https://blog.csdn.net/weixin_42638946/article/details/114905541\n最短路模型 https://www.acwing.com/solution/content/2078/ https://blog.csdn.net/weixin_43798170/article/details/113819433 https://www.acwing.com/problem/content/190/ https://blog.csdn.net/qq_30277239/article/details/104680308\n多源bfs https://www.acwing.com/problem/content/175/\n最小步数模型 https://www.acwing.com/problem/content/847/ https://www.acwing.com/problem/content/1109/\n双端队列广搜 https://www.acwing.com/problem/content/177/\nA* https://www.acwing.com/problem/content/180/ https://www.acwing.com/problem/content/181/\nDFS综合 https://blog.csdn.net/weixin_42638946/article/details/114993465\nDFS连通性模型 https://www.cnblogs.com/WAsbry/p/12836812.html https://blog.csdn.net/qq_45927003/article/details/112845344\nDFS搜索顺序 https://blog.csdn.net/weixin_45480785/article/details/113802964\nhttps://blog.csdn.net/m0_46656833/article/details/116027525\nhttps://blog.csdn.net/qq_30277239/article/details/104799213\nDFS剪枝与优化 https://www.acwing.com/problem/content/168/ https://www.acwing.com/problem/content/167/ https://www.acwing.com/problem/content/169/ https://www.acwing.com/problem/content/170/\n迭代加深 https://www.acwing.com/problem/content/172/\n双向dfs https://www.acwing.com/problem/content/173/\nIDA* https://www.acwing.com/problem/content/182/ https://www.acwing.com/problem/content/183/\n基础知识 双指针算法 https://blog.csdn.net/suxiaorui/article/details/106222438 https://blog.csdn.net/qq_30277239/article/details/100877076\n位运算 https://www.acwing.com/problem/content/description/92/ https://blog.csdn.net/weixin_43681549/article/details/113872488\n离散化 https://blog.csdn.net/weixin_43681549/article/details/113872897\nRMQ https://blog.csdn.net/qq_46105170/article/details/119861243\n区间合并 https://www.acwing.com/solution/content/2615/\n数据结构 单链表 https://www.acwing.com/problem/content/828/\n双链表 https://www.acwing.com/problem/content/829/\n栈 https://www.cnblogs.com/ITduange/p/14457644.html\n队列 https://www.cnblogs.com/ITduange/p/14457676.html\n单调栈 https://blog.csdn.net/YSA__/article/details/107499102\n单调队列 https://www.acwing.com/problem/content/156/\nKMP https://www.acwing.com/solution/content/14666/\nTrie https://www.acwing.com/problem/content/145/\nhttps://www.acwing.com/solution/content/14695/\n并查集 https://www.acwing.com/problem/content/description/838/\nhttps://blog.csdn.net/YSA__/article/details/107696344\nhttps://blog.csdn.net/qq_52358098/article/details/114220210\nhttps://blog.csdn.net/qq_52358098/article/details/114221482\nhttps://www.acwing.com/problem/content/239/\nhttps://www.acwing.com/problem/content/240/\nhttps://www.acwing.com/problem/content/241/\nhttps://www.acwing.com/problem/content/242/\n堆 https://www.acwing.com/problem/content/108/\nhttps://www.acwing.com/problem/content/840/\nhttps://blog.csdn.net/YSA__/article/details/108416108\n哈希表 https://blog.csdn.net/YSA__/article/details/108437830\nhttps://www.acwing.com/solution/content/24738/\n树状数组 https://www.acwing.com/problem/content/243/\nhttps://www.acwing.com/problem/content/244/\nhttps://www.acwing.com/problem/content/248/\nhttps://www.acwing.com/problem/content/245/\n线段树 https://www.acwing.com/problem/content/244/\nhttps://www.acwing.com/problem/content/246/\nhttps://www.acwing.com/problem/content/247/\nhttps://www.acwing.com/problem/content/249/\nhttps://blog.csdn.net/zzq0523/article/details/113183214\nhttps://blog.csdn.net/qq_52358098/article/details/117306705\n可持久化数据结构 https://www.acwing.com/problem/content/257/\nhttps://www.acwing.com/problem/content/258/\n平衡树 https://www.acwing.com/problem/content/255/\nhttps://www.acwing.com/problem/content/267/\nAC自动机 https://blog.csdn.net/weixin_43798170/article/details/114273860\nhttps://www.acwing.com/solution/content/56098/\nhttps://www.acwing.com/solution/content/7760/\n图论 单源最短路初级 https://www.acwing.com/solution/content/9306/\nhttps://www.acwing.com/problem/content/851/\nhttps://www.acwing.com/problem/content/852/\nhttps://www.acwing.com/problem/content/853/\nhttps://www.acwing.com/problem/content/855/\nhttps://blog.csdn.net/qq_44791484/article/details/116587679\nhttps://www.acwing.com/problem/content/1129/\nhttps://blog.csdn.net/qq_30277239/article/details/106104598\nhttps://blog.csdn.net/qq_30277239/article/details/106106290\nhttps://www.acwing.com/problem/content/922/\nhttps://www.acwing.com/problem/content/905/\n单源最短路中级 https://www.acwing.com/problem/content/342/\nhttps://www.acwing.com/problem/content/343/\nhttps://www.acwing.com/problem/content/344/\nhttps://blog.csdn.net/qq_30277239/article/details/106317639\n单源最短路高级 https://blog.csdn.net/qq_30277239/article/details/106864304\nhttps://www.acwing.com/problem/content/385/\nhttps://blog.csdn.net/qq_30277239/article/details/106819891\nhttps://blog.csdn.net/qq_30277239/article/details/106743915\n负环 https://blog.csdn.net/qq_30277239/article/details/101060037\nhttps://www.acwing.com/problem/content/363/\nhttps://blog.csdn.net/qq_30277239/article/details/108330375\nhttps://blog.csdn.net/qq_30277239/article/details/108436287\n差分约束 https://www.acwing.com/problem/content/364/\nhttps://www.acwing.com/problem/content/395/\nhttps://blog.csdn.net/qq_30277239/article/details/108966877 牛\nhttps://blog.csdn.net/qq_30277239/article/details/109248159\nFloyd https://blog.csdn.net/qq_30277239/article/details/101062266\nhttps://www.acwing.com/problem/content/345/\nhttps://www.acwing.com/problem/content/346/\nhttps://www.acwing.com/problem/content/347/\nhttps://blog.csdn.net/qq_30277239/article/details/107301496\n最小生成树初级 最基础的prim和kruskal\nhttps://blog.csdn.net/qq_30277239/article/details/101064096\nhttps://blog.csdn.net/qq_30277239/article/details/101066119\n较简单\nhttps://blog.csdn.net/qq_30277239/article/details/107891523\nhttps://blog.csdn.net/qq_30277239/article/details/107898613\n小技巧（最小生成树的最大边；有一些边是必选的，就输入时处理；点阵连通，不用构图，直接用性质\nhttps://blog.csdn.net/qq_30277239/article/details/107899568\nhttps://blog.csdn.net/qq_30277239/article/details/107899955\nhttps://blog.csdn.net/qq_30277239/article/details/107900698\n最小生成树中级 https://www.acwing.com/problem/content/348/\nhttps://blog.csdn.net/qq_30277239/article/details/108184284\nhttps://blog.csdn.net/qq_30277239/article/details/108038467\nhttps://blog.csdn.net/qq_30277239/article/details/108033213\nhttps://blog.csdn.net/qq_30277239/article/details/108190012\n欧拉回路 https://blog.csdn.net/weixin_42638946/article/details/115432734\n拓扑排序 https://blog.csdn.net/weixin_42638946/article/details/115442368\n最近公共祖先 https://blog.csdn.net/weixin_42638946/article/details/115321434\n有向图强连通分量 https://blog.csdn.net/weixin_42638946/article/details/115385877 牛\nhttps://blog.csdn.net/qq_30277239/article/details/118683637\nhttps://blog.csdn.net/qq_30277239/article/details/118880405\nhttps://www.acwing.com/problem/content/370/\n无向图双连通分量 https://blog.csdn.net/weixin_42638946/article/details/115413418 牛\nhttps://www.acwing.com/problem/content/397/\nhttps://www.acwing.com/problem/content/398/\n染色体法 and匈牙利算法 二分图 https://blog.csdn.net/weixin_42638946/article/details/115422539\n数学知识 质数 https://blog.csdn.net/weixin_42638946/article/details/115703334\n约数 https://blog.csdn.net/weixin_42638946/article/details/115706223\n快速幂 https://blog.csdn.net/weixin_42638946/article/details/115716902\n欧拉函数 https://blog.csdn.net/weixin_42638946/article/details/115708467\n扩展欧几里得算法 https://blog.csdn.net/weixin_42638946/article/details/115719532\n中国剩余定理 https://blog.csdn.net/weixin_42638946/article/details/115728340\n矩阵乘法 https://blog.csdn.net/weixin_42638946/article/details/115872469\n高斯消元 https://blog.csdn.net/weixin_42638946/article/details/115736209\n组合数 https://blog.csdn.net/weixin_42638946/article/details/115751984\n容斥原理 https://blog.csdn.net/weixin_42638946/article/details/115764996\n概率与数学期望 https://www.acwing.com/problem/content/219/\nhttps://www.acwing.com/problem/content/220/\n模拟退火 https://blog.csdn.net/weixin_42638946/article/details/120817011\n博弈论 https://blog.csdn.net/weixin_42638946/article/details/115772126\n","permalink":"https://kevinerr.github.io/posts/algorithm/acwing/","summary":"找出数组中重复的元素 n个数（每个数的取值范围是1到n-1） https://www.acwing.com/solution/content/707/ 把每个数放到它原本的位置上去O(n),O(1),数组发生了改变 https://www.acwing.com/solution/content/693/ 抽屉原理二分法，","title":"acwing"},{"content":"Eureka Spring Cloud Eureka是Spring Cloud Netflix 子项目的核心组件之一，主要用于微服务架构中的服务治理。本文将对搭建Eureka注册中心，搭建Eureka客户端，搭建Eureka集群及给Eureka注册中心添加登录认证进行介绍。\n在微服务架构中往往会有一个注册中心，每个微服务都会向注册中心去注册自己的地址及端口信息，注册中心维护着服务名称与服务实例的对应关系。每个微服务都会定时从注册中心获取服务列表，同时汇报自己的运行情况，这样当有的服务需要调用其他服务时，就可以从自己获取到的服务列表中获取实例地址进行调用，Eureka实现了这套服务注册与发现机制。\n由于所有服务都会注册到注册中心去，服务之间的调用都是通过从注册中心获取的服务列表来调用，注册中心一旦宕机，所有服务调用都会出现问题。所以我们需要多个注册中心组成集群来提供服务，下面将搭建一个双节点的注册中心集群。\nRibbon Spring Cloud Ribbon 是Spring Cloud Netflix 子项目的核心组件之一，主要给服务间调用及API网关转发提供负载均衡的功能，本文将对其用法进行详细介绍。\n在微服务架构中，很多服务都会部署多个，其他服务去调用该服务的时候，如何保证负载均衡是个不得不去考虑的问题。负载均衡可以增加系统的可用性和扩展性，当我们使用RestTemplate来调用其他服务时，Ribbon可以很方便的实现负载均衡功能。 RestTemplate是一个HTTP客户端，使用它我们可以方便的调用HTTP接口，支持GET、POST、PUT、DELETE等方法。 所谓的负载均衡策略，就是当A服务调用B服务时，此时B服务有多个实例，这时A服务以何种方式来选择调用的B实例，ribbon可以选择以下几种负载均衡策略。\nHystrix Spring Cloud Hystrix 是Spring Cloud Netflix 子项目的核心组件之一，具有服务容错及线程隔离等一系列服务保护功能，本文将对其用法进行详细介绍。\n在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。\n@HystrixCommand中的常用参数 fallbackMethod：指定服务降级处理方法； ignoreExceptions：忽略某些异常，不发生服务降级； commandKey：命令名称，用于区分不同的命令； groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息； threadPoolKey：线程池名称，用于划分线程池。\nHystrix的请求缓存 当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。 @CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key； @CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定； @CacheRemove：移除缓存，需要指定commandKey。\n请求合并 微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。Hystrix中提供了@HystrixCollapser用于合并请求，从而达到减少通信消耗及线程数量的效果。 batchMethod：用于设置请求合并的方法； collapserProperties：请求合并属性，用于控制实例属性，有很多； timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；\nFeign Spring Cloud OpenFeign 是声明式的服务调用工具，它整合了Ribbon和Hystrix，拥有负载均衡和服务容错功能，本文将对其用法进行详细介绍。\nFeign是声明式的服务调用工具，我们只需创建一个接口并用注解的方式来配置它，就可以实现对某个服务接口的调用，简化了直接使用RestTemplate来调用服务接口的开发量。Feign具备可插拔的注解支持，同时支持Feign注解、JAX-RS注解及SpringMvc注解。当使用Feign时，Spring Cloud集成了Ribbon和Eureka以提供负载均衡的服务调用及基于Hystrix的服务容错保护功能。\nZuul Spring Cloud Zuul 是Spring Cloud Netflix 子项目的核心组件之一，可以作为微服务架构中的API网关使用，支持动态路由与过滤功能，本文将对其用法进行详细介绍。\nAPI网关为微服务架构中的服务提供了统一的访问入口，客户端通过API网关访问相关服务。API网关的定义类似于设计模式中的门面模式，它相当于整个微服务架构中的门面，所有客户端的访问都通过它来进行路由及过滤。它实现了请求路由、负载均衡、校验过滤、服务容错、服务聚合等功能。\n过滤器 路由与过滤是Zuul的两大核心功能，路由功能负责将外部请求转发到具体的服务实例上去，是实现统一访问入口的基础，过滤功能负责对请求过程进行额外的处理，是请求校验过滤及服务聚合的基础。 pre：在请求被路由到目标服务前执行，比如权限校验、打印日志等功能； routing：在请求被路由到目标服务时执行，这是使用Apache HttpClient或Netflix Ribbon构建和发送原始HTTP请求的地方； post：在请求被路由到目标服务后执行，比如给目标服务的响应添加头信息，收集统计数据等功能； error：请求在其他阶段发生错误时执行。 由于Zuul自动集成了Ribbon和Hystrix，所以Zuul天生就有负载均衡和服务容错能力，我们可以通过Ribbon和Hystrix的配置来配置Zuul中的相应功能。\n","permalink":"https://kevinerr.github.io/posts/tech/springcloud/","summary":"Eureka Spring Cloud Eureka是Spring Cloud Netflix 子项目的核心组件之一，主要用于微服务架构中的服务治理。本文将对搭建Eureka注册中心，搭建Eureka","title":"springcloud"},{"content":"快门速度、iso以及光圈数值 快门速度：相机左下角的参数就是快门速度，指快门打开到闭合所需要的时间。快门速度越快，你定格的时间越短，比如：快门速度越快，你就可以定格住运动的物体；相反，快门速度越慢，运动物体会糊掉，快门速度会影响曝光，也就是对照片的亮度有影响 光圈：镜头的字母F后面的就是光圈数值，这个数字越小，光圈越大，虚化效果也越好，也越容易剁手。 ISO：可以比作相机内部的一个手电筒，开得太高，会出现噪点，要注意哦。\n焦段 长焦压缩 背景和人物看上去更近\n35mm 广角 背景多点 显脸大\n50mm 55mm最适合拍摄 我想说的是，实际上很多女摄影师都非常喜欢24mm定焦拍的人像，虽然确实是有畸变，但是面部五官也立体了，长焦扁平压缩背景的同时也扁平了人脸。大家可以去试试24mm拍出来的直出图给摸特看看，特别是竖拍图，保证模特大多数都会喜欢\n单反转盘模式说明 1.A+档：根据场景设置，自动调节对焦、亮度、色调，还能调出使用闪光灯（完全由相机自己觉得照片质量） 2.P档：自动设置快门光圈值，也可手动设置 3.S/TV档：快门优先自动曝光，可调节快门速度，使物体显得静止或动感，此模式下只需要设置好快门速度，相机程序会自动调节好光圈大小，比较适合高速运动物体抓拍。（由于无法控制光圈大小，所以无法控制景深） 4.A档：和S档相反，光圈优先自动曝光，快门根据光圈大小得出适当数值，适合拍摄景物（如果光圈很小，快门也会变的很慢，没有三脚架，画面易变模糊） 5.M档：手动曝光，手动设置快门、光圈、ISO、白平衡等所有数值（但是要想拍出满意的照片，需要尝试很多次） 6.B门：快门调到最慢，快门的数字会变成B门，快门时间取决于按快门持续的时间（适合拍车流、星轨，需要搭配三脚架和快门线使用）\n互易律 通过上面的实验你就会发现，在同等光线环境下，光圈小1档，快门慢1档位，ISO不动，画面的亮度是不会变了，这就是互易律。\n光圈、快门、感光度，这三者中的任意一个或者两个朝明或暗调节了N档，另外的两个或者一个朝着反方向调节N档位，整体曝光不变。\n","permalink":"https://kevinerr.github.io/posts/life/%E6%91%84%E5%BD%B1/","summary":"快门速度、iso以及光圈数值 快门速度：相机左下角的参数就是快门速度，指快门打开到闭合所需要的时间。快门速度越快，你定格的时间越短，比如：快门","title":"摄影"},{"content":"数据库引擎 MyISAM：表锁，并发量较小，不支持事务，不支持外键（性能更优，占用的存储空间少，MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率，查询性能高）\nInnoDB：行锁，并发量较大，支持事务，支持外键。是聚集索引，使用B加Tree作为索引结构。\nTips 安装mysql 一般用压缩包安装，而不用exe安装\nmysql是数据库管理系统\n锁 行锁与表锁\n当插入数据时，就锁定表，这叫做”锁表”；当更新数据时，就锁定行，这叫做”锁行”。\nmysql的行锁是基于索引加载的\n表锁响应的是非索引字段，即全表扫描，\n更新数据库数据时，如果没有触发索引，则会锁表，锁表后再对表做任何变更操作都会导致锁冲突，所以表锁的锁冲突概率较高。\n连表查询 7种 用基础的3种left join、right join、inner join搞定7种\n自连接 自连接查询就是以类似多表对比的方式，实现对同一张表内数据进行复杂的关系表示或关系处理。\n子查询 MySQL函数 常用函数\n聚合函数\nMD5加密\nSQL语句书写 1 2 3 4 5 6 7 8  DESC `cms_help` --显示表的结构 SHOW CREATE TABLE `cms_help` --查看创建数据表的语句 SHOW CREATE DATABASE `mall` --查看创建数据库的语句 ALTER --对表的列进行操作 TRUNCATE TABLE \u0026#39;test\u0026#39; DELETE FROM \u0026#39;test\u0026#39; --都能删除数据,不会删除表结构，TRUNCATE重新设置自增类，计数器归零，不会影响事务 SELECT DISTINCT --去重   DELETE删除的问题，重启数据库\nInnoDB 自增从1开始（存在内存中，断电即失）\nMyISAM 继续上一个自增（存在文件中，不会丢失）\nmodify不能用来字段重命名\nchange不能修改字段类型和约束\n外键一般用程序是实现，一切外键概念必须在应用层解决\n分页limit 起始值 页面的大小和排序order by asc/desc\n分库分表 垂直分库 垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。\n它带来的提升是：\n 解决业务层面的耦合，业务清晰 能对不同业务的数据进行分级管理、维护、监控、扩展等 高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈  业务场景：原有的SELLER_DB(卖家库)，分为了PRODUCT_DB(商品库)和STORE_DB(店铺库)，并把这两个库分散到不同服务器\n水平分库 水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。\n它带来的提升是：\n 解决了单库大数据，高并发的性能瓶颈。 提高了系统的稳定性及可用性。  业务场景：经过垂直分库后，数据库性能问题得到一定程度的解决，但是随着业务量的增长，PRODUCT_DB(商品库)单库存储数据已经超出预估。粗略估计，目前有8w店铺，每个店铺平均150个不同规格的商品，再算上增长，那商品数量得往1500w+上预估，并且PRODUCT_DB(商品库)属于访问非常频繁的资源，单台服务器已经无法支撑。此时该如何优化？尝试水平分库，将店铺ID为单数的和店铺ID为双数的商品信息分别放在两个库中。\n垂直分表 垂直分表定义：将一个表按照字段分成多表，每个表存储其中一部分字段。\n用户在浏览商品列表时，只有对某商品感兴趣时才会查看该商品的详细描述。因此，商品信息中商品描述字段访问频次较低，且该字段存储占用空间较大，访问单个数据IO时间较长；商品信息中商品名称、商品图片、商品价格等其他字段数据访问频次较高。\n由于这两种数据的特性不一样，因此他考虑将商品信息表拆分如下：\n将访问频次低的商品描述信息单独存放在一张表中，访问频次较高的商品基本信息单独放在一张表中\n它带来的提升是：\n1.为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响\n2.充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。\n通常我们按以下原则进行垂直拆分:\n1 把不常用的字段单独放在一张表;\n2 把text，blob等大字段拆分出来放在附表中;\n3 经常组合查询的列放在一张表中;\n水平分表 水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。\n它带来的提升是：\n 优化单一表数据量过大而产生的性能问题 避免IO争抢并减少锁表的几率  业务场景：按照水平分库的思路对他把PRODUCT_DB_X(商品库)内的表也可以进行水平拆分，其目的也是为解决单表数据量大的问题\n主从复制，读写分离 主从复制原理（数据层面的东西）\n在不同的服务器上配置数据库，并通过修改配置文件构成主从复制\n读写分离（shardingJDBC：业务层面的东西）\n读只会使用2台从服务器\n写只会在主服务器\n分库分表查询语句会查询所有库和所有表的数据\nshardingJDBC还提供分布式事务\n1 2 3 4 5 6 7  分库分表后，本地事务已经不能保证事务，需要分布式事务 ## 本地事务 @Transactional（rollbackFor = Exception.class） ## Sharding提供的分布式事务 ## 扣钱--\u0026gt;强一致性 ； 订单 --\u0026gt; 弱一致性，柔性 @Transactional（rollbackFor = Exception.class） @ShardingTransactionType(TransactionType.XA)   事务以及隔离级别 事务是一系列操作的集合，这些操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的最小工作单元。 事务（原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）） 创建一个名为transfer1的显式事务，该事务将学生李勇校园卡账户上的500元转到张立的校园卡账户上，然后用select语句查看campus_card表检查是否转账成功。要求：（1）先基于学生姓名获得其学号信息；（2）转账前需要先检查李勇的校园卡账户是否有足够的待转金额，如果若李勇账户余额不足则打印输出‘余额不足，不能转账.’然后将该事务回滚。\n索引（有序数组、Hash、二叉搜索树、B+树） 创建索引可以大大提高系统的性能。 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 第二，可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。\n创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。 第二，索引需要占物理空间\n主键索引 顾名思义该类索引由表的主键组成，从左到右由小到大排序。一个 Innodb 存储表只有一张主键索引表（聚集索引）。 普通索引 最为平常的一种索引，没有特别限制。 唯一索引 该索引的字段不能有相同值，但允许有空值。 组合索引 由多列字段组合而成的索引，往往是为了提升查询效率而设置。 聚集索引就是按照每张表的主键构造一棵 B+树，叶子节点存放的是表的完整行记录。非聚集索引的叶子节点不包含行记录的全部数据。Innodb 存储引擎的非聚集索引的叶子节点的内容为主键索引值。\n索引不是越多越好\n不要对经常变动的数据加索引\n小数据量的表不需要加索引\n索引一般加在常用来查询的字段上\n函数或表达式会使索引失效\n最左前缀原理（查询条件没有指定索引第一列，用不到索引；询条件用到了索引中列的精确匹配，但是中间某个条件未提供，会出现“坑”；通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）\n使用辅助索引或“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。\n范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引\n“BETWEEN”实际上相当于“IN”是多值匹配，谨慎地区分多值匹配和范围匹配\n索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值，择性的取值范围为(0, 1]，选择性越高的索引价值越大\n前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。\n在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。\n存储过程 性能好；将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。 exec 执行存储过程\n触发器 响应一个特殊表格中的某些事件而自动执行的程序代码 触发器是一种特殊类型的存储过程，不由用户直接调用。创建触发器时会对其进行定义，以便在对特定表或列作特定类型的数据修改时执行。 保证数据完整性的一种方法 DML触发器(Insert,delete,update)、DDL(create,drop,alter)触发器和登录触发器 当用户从course表删除元组时检查被删除元组的课程号（cno）是否在学生选课表sc中出现过，如果出现过说明该课程已被学生选，为了保证数据库的完整性，这时应该将表sc中对应该课程号的选课信息给删除。 过多的触发器使得数据逻辑变得复杂。触发器的功能逐渐在代码逻辑或事务中替代实现，更符合OO思想。建议：使用触发器需慎重。\n视图 视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成； 特点：视图中的数据并不属于视图本身；视图的数量没有限制，但是命名不能和视图以及表重复，具有唯一性。视图可以被嵌套，一个视图中可以嵌套另一个视图。 视图不能索引，不能有相关联的触发器和默认值 好处：①简化数据操作：视图可以简化用户处理数据的方式。 ②着重于特定数据：不必要的数据或敏感数据可以不出现在视图中。 ③视图提供了一个简单而有效的安全机制，可以定制不同用户对数据的访问权限。\n数据库设计 1、需求分析：了解用户的数据需求、处理需求、安全性及完整性要求； 2、概念设计：通过数据抽象，设计系统概念模型，一般为E-R模型； 3、逻辑结构设计：设计系统的模式和外模式，对于关系模型主要是基本表和视图； 4、物理结构设计：设计数据的存储结构和存取方法，如索引的设计； 5、系统实施：组织数据入库、编制应用程序、试运行； 6、运行维护：系统投入运行，长期的维护工作。\n范式  第一范式：要求数据库表的每一列都是不可分割的原子数据项。 第二范式：（2NF）属性完全依赖于主键 第三范式：（3NF）属性不依赖于其它非主属性，在2NF基础上消除传递依赖 BCNF 在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖。  数据迁移 情景:把一个数据库的一些表迁移到另外一个新的数据库的表中. 同时, 在迁移过程中, 修改一些数据. 此处, 修改数据, 举几个例子:\n Y/N, Yes/No 改成 TRUE/FALSE 添加一些新列, 并填充默认值 原来的列, 名字全部修改. 比如 Event ID 改成 XXEvent ID 筛选归类. 比如原来某列的数据是1-100的分数, 迁移后数据转换成\u0026quot;不及格\u0026quot;(\u0026lt;60),\u0026ldquo;及格\u0026rdquo;(60\u0026lt;x\u0026lt;70), 优良..等等 拆分原来的列. 原来的列里日期数据是DD/MM/YYYY HH:mm:ss, 拆成两列, 一列是MM/DD/YYYY, 另一列是HH:mm:ss 等等等等 现在只能拿到 CSV 格式数据. 一个 CSV 是一个表格, 有很多很多表格. 一个表格大概4W 到40W 行不等. 光是一个 CSV 大小,就有100来兆. 请问除了用 excel, 有什么好的办法或者软件或者服务可以处理? 数据迁移工具  SQL注入 preparedstatement防止sql注入的本质，把传递进来的参数当作字符\n假设其中存在转义字符，比如说‘会被直接转义\n数据库连接池 ","permalink":"https://kevinerr.github.io/posts/tech/%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"数据库引擎 MyISAM：表锁，并发量较小，不支持事务，不支持外键（性能更优，占用的存储空间少，MYISAM拥有全文索引的功能，这可以极大地优","title":"数据库"},{"content":"概述 并发、共享、虚拟、异步 计算机系统资源的管理者；用户与计算机硬件之间的接口；扩充机器（工人）\n进程/线程 1、进程是什么？ 是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独 立运行的一段程序。 2、线程又是什么？ 线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。 在运行时，只是暂用一些计数器、寄存器和栈 。\n并发/锁 确保线程安全最常见的做法是利用锁机制（Lock、sychronized）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。\n可重入锁，顾名思义，指的是线程可以重复获取同一把锁。即同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。 可重入锁可以在一定程度上避免死锁。\n公平锁 - 公平锁是指 多线程按照申请锁的顺序来获取锁。 非公平锁 - 非公平锁是指 多线程不按照申请锁的顺序来获取锁 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。\n独享锁 - 独享锁是指 锁一次只能被一个线程所持有。 共享锁 - 共享锁是指 锁可被多个线程所持有。\n悲观锁 - 悲观锁对于并发采取悲观的态度，认为：不加锁的并发操作一定会出问题。悲观锁适合写操作频繁的场景。 乐观锁 - 乐观锁对于并发采取乐观的态度，认为：不加锁的并发操作也没什么问题。对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用不断尝试更新的方式更新数据。乐观锁适合读多写少的场景。\n悲观锁与乐观锁在 Java 中的典型实现： 悲观锁在 Java 中的应用就是通过使用 synchronized 和 Lock 显示加锁来进行互斥同步，这是一种阻塞同步。 乐观锁在 Java 中的应用就是采用 CAS 机制（CAS 操作通过 Unsafe 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。\n内存管理和调度 连续分配、非连续分配、虚拟内存、请求分页、页面置换、页面分配、地址翻译（页号比较页表长度\u0026ndash;页表项是否在快表中\u0026ndash;页表中（在，修改访问位和修改位）\u0026ndash;缺页中断外存中找缺页\u0026ndash;调页或页面置换\u0026ndash;修改页表）\n文件管理 文件的逻辑结构、目录结构（FCB、索引节点）、文件共享、文件保护 文件分配（连续、链接、索引分配）、文件存储空间管理（空闲表法、链表法、位示图法、成组链接法） 磁盘（访问时间、调度算法、磁盘的管理（初始块、引导块、坏块））\nI/O原理 I/O控制方式（程序直接控制、中断、DMA、通道控制方式） I/O层次结构（用户层I/O、设备独立性软件、设备驱动器、中断处理层、硬件层） 缓冲区、设备分配、SPOOLing系统\n","permalink":"https://kevinerr.github.io/posts/tech/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"概述 并发、共享、虚拟、异步 计算机系统资源的管理者；用户与计算机硬件之间的接口；扩充机器（工人） 进程/线程 1、进程是什么？ 是具有一定独立功能的","title":"操作系统"},{"content":"网络的功能 计算机网络的功能主要体现在资源共享、数据通信和分布式处理三个方面。资源共享是计算机网络用户提供的最主要的功能，资源是指在有限时间内可为用户提供各种服务的软、硬件，资源共享是指网络中的用户能够全部地使用网络中的资源，包括软件共享、硬件共享和数据共享，通常，用户本身不需要考虑自己所使用的资源在网络中的具体位置。\n数据通信主要完成资源子网中各个独立的计算机系统之间的信息数据的传递，分布式处理则是利用网络技术多个独立的计算机系统连接组合成一个高性能的计算机系统，计算机群集，分布式系统，网络等都是这一功能应用的典型实例。\nCOOKIE/SESSION https://www.jianshu.com/p/6623416161ff\n 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。  访问网站 1、在浏览器输入url 2、浏览器向DNS解析url的ip地址 3、浏览器与服务器建立tcp连接（默认端口号80；2个套接字确定一条tcp连接） 4、浏览器发出http请求（get index.html) 5、服务器通过http将index.html发送给浏览器 6、tcp连接释放，浏览器解释文件index.html，并将web页显示给用户 HTTP缓存 https://www.jianshu.com/p/227cee9c8d15\nHTTP 超文本传输协议HyperText Transfer Protocol\n基于TCP协议的应用层传输协议\n客户端和服务端\n无状态 (stateless) 协议 Cookie\nConnection: Keep-Alive实现长连接\n正在传输的类型由Content-Type加以标记\n在实际的应用中，客户端往往会发出一系列请求，接着服务器端对每个请求进行响应。对于这些请求|响应，如果每次都经过一个单独的TCP连接发送，称为非持久连接。反之，如果每次都经过相同的TCP连接进行发送，称为持久连接。\n非持久连接在每次请求|响应之后都要断开连接，下次再建立新的TCP连接，这样就造成了大量的通信开销。例如前面提到的往返时间(RTT) 就是在建立TCP连接的过程中的代价。\nHTTP请求 由请求行，消息报头，请求正文三部分构成\n1、请求行由请求Method, URL 字段和HTTP Version三部分构成\n1  GET /example.html HTTP/1.1 (CRLF)   2、消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息\n3、HTTP请求正文\n只有在发送POST请求时才会有请求正文，GET方法并没有请求正文\nHTTP响应 也由三部分组成，包括状态行，消息报头，响应正文。\n1、状态行也由三部分组成，包括HTTP协议的版本，状态码，以及对状态码的文本描述。例如\n1  HTTP/1.1 200 OK （CRLF）   GET/POST  GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密） GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源） GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有 GET可以被保存为书签，POST不可以。这一点也能感受到。 GET能被缓存，POST不能 GET只允许ASCII字符，POST没有限制 GET会保存再浏览器历史记录中，POST不会。这点也能感受到。  HTTPS 内容加密建立一个信息安全通道，来保证数据传输的安全；\n身份认证确认网站的真实性\n数据完整性防止内容被第三方冒充或者篡改\nSSL (Secure Socket Layer，安全套接字层)\nTLS (Transport Layer Security，传输层安全协议)\nTLS\n协议 https://zhuanlan.zhihu.com/p/93894145\n电子邮件 SMTP（simple mail transfer protocol）推 POP3（post office protocol邮局协议）拉 MIME（multipurpose internet mail extensions多用途网络邮件补充）：非ASCII码数据 IMAP（因特网报文存取协议）：只读报文的某一部分\nNAT (Network Address Translation)网络地址转换\n私有地址（10 172 192）\u0026ndash;公用地址\n该网络中的主机使用私用IP地址.当私有网络内部主机和外部Internet通信时,网关(gateway)路由器负责将私有IP地址转换为全球IP地址\nNAPT (Network Address and Port Translation)\nCIDR Classless Inter-Domain Routing，无类域间路由\n细分网络、子网掩码、CIDR（构成超网，查找路由表最长前缀匹配）\nARP 地址解析协议，即ARP（Address Resolution Protocol）根据IP地址获取物理地址的一个TCP/IP协议\n工作过程\n假设主机A和B在同一个网段，主机A要向主机B发送信息，具体的地址解析过程如下：\n 主机A首先查看自己的ARP缓存表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。  当主机A和主机B不在同一网段时，主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。\nDHCP DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）\n是一个局域网的网络协议，使用UDP协议工作，统一使用两个IANA分配的端口：67（服务器端），68（客户端）。DHCP通常被用于局域网环境，主要作用是集中的管理、分配IP地址，使client动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。\nICMP ping/traceroute\nICMP是 Internet Control Message Protocol 的缩写，即互联网控制消息协议\n它用于 TCP/IP 网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使网络管理者可以对所发生的问题作出诊断，然后采取适当的措施解决问题。虽然 ICMP 是网络层协议，但是它不像 IP 协议和 ARP 协议一样直接传递给数据链路层，而是先封装成 IP 数据包然后再传递给数据链路层。所以在 IP 数据包中如果协议类型字段的值是 1 的话，就表示 IP 数据是 ICMP 报文。\nICMP协议的类型分为两大类，查询报文和差错报文。\n非对称加密RSA 公钥(E,N) 私钥（D,N）\nCDN Content Delivery Network，内容分发网络\nhttps://zhuanlan.zhihu.com/p/52362950\n诞生 随着互联网的爆炸式发展，网络拥塞越来越严重，将会成为互联网发展的最大障碍。\n原理 CDN这个技术其实说起来并不复杂，最初的核心理念，就是将内容缓存在终端用户附近。\n内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？\nVPN 应用：居家办公、访问校园网、访问**\nISP（Internet Service Provider）：因特网服务提供商\nVPN（Virtual Private Network）：虚拟专用网络\n站点\u0026ndash;站点 VPN 客户端站点VPN、远程登录VPN 不需要长时间进行链接、使用浏览器通信、\n全隧道、半隧道\nVPN的职责 加密（不然你知道、完整（数据被你破坏、认证（电脑被你黑了\nVPN框架 IPsec（网络层、SSL/TLS（表示层\n","permalink":"https://kevinerr.github.io/posts/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"网络的功能 计算机网络的功能主要体现在资源共享、数据通信和分布式处理三个方面。资源共享是计算机网络用户提供的最主要的功能，资源是指在有限时间内","title":"计算机网络"},{"content":"Linux常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  打包并压缩文件:“tar -czvf 压缩包名.tar.gz 文件名” 解压并展开压缩包:“tar -xzvf 压缩包名.tar.gz” unzip 解压后缀名.zip的文件   sync #将数据从内存同步到硬盘 shutdown -h 10 #十分钟后关机 reboot #重启=shutdown -r now halt #关闭系统=shutdown -h now  cd ~ #回到当前用户目录 mkdir -p test2/test3/test4 #递归创建文件夹 rmdir -p test2/test3/test4 #递归删除多个目录  cp #只能复制文件  rm -rf #GG -f强制删除 -r递归删除  mv #移动文件和文件夹或重命名文件夹   */：* 根目录，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中 */bin:/usr/bin:* 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 */boot：* 放置linux系统启动时用到的一些文件。/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可 */dev：* 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt。 */etc：* 系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。注：/etc/X11存放与x windows有关的设置。 */home：* 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据 */lib:/usr/lib:/usr/local/lib：* 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules。 */lost+fount：* 系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于/disk 中，此目录下就会自动产生目录/disk/lost+found */mnt:/media：* 光盘默认挂载点，通常光盘挂载于/mnt/cdrom下，也不一定，可以选择任意位置进行挂载。 */opt：* 给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 /usr/local 目录下 */proc：* 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/等 */root：* 系统管理员root的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下。 */sbin:/usr/sbin:/usr/local/sbin：* 放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能\u0026quot;查看\u0026quot;而不能设置和使用。 */tmp：* 一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下 /srv： 服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内 **/usr： 应用程序存放目录，*/usr/bin** 存放应用程序**， /usr/share 存放共享数据，*/usr/lib* 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local:存放软件升级包。*/usr/share/doc:* 系统说明文件存放目录。*/usr/share/man:* 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间 */var：* 放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message： 所有的登录文件存放目录，*/var/spool/mail：* 邮件存放的目录，/var/run: 程序或服务启动\n文件基本属性   当为 d 则是目录\n  当为 - 则是文件；\n  若是 l 则表示为链接文档(link file)；\n  若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\n  若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\n1 2 3  chmod #change mode chown #change ownership chgrp #change group     查看文件 1 2 3 4 5 6 7 8 9 10 11 12 13   cd /etc/sysconfig/network-scripts/  cat -n #-n显示行号，用于显示小文件的内容，或者在shell脚本里显示文件内容，不支持翻页。  tac #从最后一行开始  head  tail  more  less #最好用，上下翻页，q键退出 /要查询的字符向下查询 ?向上查询     touch f1#创建文件  ln f1 f2  ln -s f1 f3  echo \u0026#34;i love djx\u0026#34; \u0026gt;\u0026gt;f1 #输入字符串   硬链接：拷贝，只有数目为0时才删除\n软链接：快捷方式\n账号管理 1 2 3 4 5 6 7 8  useradd djx #-G给用户分配组 cat /etc/password #用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell userdel -r djx usermod -d /home/z passwd 选项 用户名 #-l 锁定口令，即禁用账号。 -u 口令解锁。 passwd djx su djx hostname   用户组管理 1 2 3 4 5 6 7 8   groupadd -g 520 djx #指定520端口号，不指定默认自增1  cat /etc/group  groupdel  groupmod -g 666 -n newdjx djx  su djx  newgrp root #切换组   cat /etc/shadow #登录口令 加密的   磁盘管理  列出文件系统的整体磁盘使用量 检查磁盘空间使用量 磁盘分区 磁盘格式化 磁盘检验 磁盘的挂载与删除  1 2 3 4 5 6  df df -h du mkdir /mnt/hdc6 mount /dev/hdc6 /mnt/hdc6 #Mac插入u盘或磁盘需要挂载到mnt目录中才能使用 umount /dev/hdc6   进程管理 基本概念\n linux中，每个程序都有自己的进程，每个进程都有一个id号 每个进程都有一个父进程 进程有前台和后台运行2种方式 一般服务后台运行，程序前台运行  命令\n1 2 3 4  ps -aux kill -9 进程id  nohup 代表后台z   文件：读写执行（查看、创建、删除、移动、复制、编辑），权限（用户、用户组），系统（磁盘、进程）\n下载环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # rpm下载 mkdir java#下载jdk rpm java -version #查看版本 rpm -qa|grep jdk #检测jdk版本信息 rpm -e --nodeps xx #卸载jdk，xx表示检测出来的jdk rpm -ivh rpm包 #安装，-i是安装（install），-v是列出更多详细信息（verbose），-h是在安装时列出hash标记  #tar下载 mkdir java #在/usr下新建文件夹 tar -zxvf jdk-8u171-linux-x64.tar.gz #得到文件夹：jdk1.8.0_171 vim /etc/profile #修改配置环境，添加以下环境,rpm安装不用配，解压缩才用配 \tJAVA_HOME=/usr/java/jdk1.8.0_171  CLASSPATH=$JAVA_HOME/lib/  PATH=$PATH:$JAVA_HOME/bin  export PATH JAVA_HOME CLASSPATH source /etc/profile #重新加载文件 java -version #查看版本  #yum下载 yum list installed |grep java #查看是否自带jdk yum -y remove java-1.8.0-openjdk.x86_64 yum -y remove tzdata-java.noarch #卸载掉自带的 yum -y list java* #查看yum库中的Java安装包 yum -y install java-1.8.0-openjdk*   防火墙 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  常用命令： systemctl start firewalld #启动 systemctl stop firewalld #停止 systemctl status firewalld #查看状态  开放或关闭端口： firewall-cmd --zone=public --add-port=80/tcp --permanent #开放80/tcp端口 （--permanent永久生效，没有此参数重启后失效） firewall-cmd --zone=public --query-port=80/tcp #查看80/tcp端口 firewall-cmd --zone=public --remove-port=80/tcp --permanent #关闭80/tcp端口  批量开放或关闭端口： firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent #批量开放端口，打开从40000到45000之间的所有端口 firewall-cmd --zone=public --list-ports #查看系统所有开放的端口 firewall-cmd --zone=public --remove-port=40000-45000/tcp --permanent #批量关闭端口，关闭从40000到45000之间的所有端口  更新防火墙的设置： firewall-cmd --reload #更新防火墙的设置，使上面的修改生效  阿里云还需配置安全组规则   shell脚本 ACwing 常用文件管理命令 https://www.acwing.com/file_system/file/content/whole/index/content/2855620/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (1) ctrl c: 取消命令，并且换行 (2) ctrl u: 清空本行命令 (3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项 (4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件 (5) pwd: 显示当前路径 (6) cd XXX: 进入XXX目录下, cd .. 返回上层目录 (7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt (8) mkdir XXX: 创建目录XXX (9) rm XXX: 删除普通文件; rm XXX -r: 删除文件夹 (10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令 (11) touch XXX: 创建一个文件 (12) cat XXX: 展示文件XXX中的内容 (13) 复制文本  windows/Linux下：Ctrl + insert，Mac下：command + c (14) 粘贴文本  windows/Linux下：Shift + insert，Mac下：command + v   tmux教程 https://www.acwing.com/file_system/file/content/whole/index/content/2855620/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  功能：  (1) 分屏。  (2) 允许断开Terminal连接后，继续运行进程。 结构：  一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。  实例：  tmux:  session 0:  window 0:  pane 0  pane 1  pane 2  ...  window 1  window 2  ...  session 1  session 2  ... 操作：  (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。  (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。  (3) 按下Ctrl + a后手指松开，然后按\u0026#34;（注意是双引号\u0026#34;）：将当前pane上下平分成两个pane。  (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。  (5) 鼠标点击可以选pane。  (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。  (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。  (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。  (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。  (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。  (11) tmux a：打开之前挂起的session。  (12) 按下ctrl + a后手指松开，然后按s：选择其它session。  方向键 —— 上：选择上一项 session/window/pane  方向键 —— 下：选择下一项 session/window/pane  方向键 —— 右：展开当前项 session/window  方向键 —— 左：闭合当前项 session/window  (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。  (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。  (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。  (16) 鼠标滚轮：翻阅当前pane内的内容。  (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）  (18) tmux中复制/粘贴文本的通用方式：  (1) 按下Ctrl + a后松开手指，然后按[  (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板  (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处   vim教程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  功能：  (1) 命令行模式下的文本编辑器。  (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。  (3) 使用方式：vim filename  如果已有该文件，则打开它。  如果没有该文件，则打开个一个新的文件，并命名为filename 模式：  (1) 一般命令模式  默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。  (2) 编辑模式  在一般命令模式里按下i，会进入编辑模式。  按下ESC会退出编辑模式，返回到一般命令模式。  (3) 命令行模式  在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。  可以查找、替换、保存、退出、配置编辑器等。 操作：  (1) i：进入编辑模式  (2) ESC：进入一般命令模式  (3) h 或 左箭头键：光标向左移动一个字符  (4) j 或 向下箭头：光标向下移动一个字符  (5) k 或 向上箭头：光标向上移动一个字符  (6) l 或 向右箭头：光标向右移动一个字符  (7) n\u0026lt;Space\u0026gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符  (8) 0 或 功能键[Home]：光标移动到本行开头  (9) $ 或 功能键[End]：光标移动到本行末尾  (10) G：光标移动到最后一行  (11) :n 或 nG：n为数字，光标移动到第n行  (12) gg：光标移动到第一行，相当于1G  (13) n\u0026lt;Enter\u0026gt;：n为数字，光标向下移动n行  (14) /word：向光标之下寻找第一个值为word的字符串。  (15) ?word：向光标之上寻找第一个值为word的字符串。  (16) n：重复前一个查找操作  (17) N：反向重复前一个查找操作  (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2  (19) :1,$s/word1/word2/g：将全文的word1替换为word2  (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。  (21) v：选中文本  (22) d：删除选中的文本  (23) dd: 删除当前行  (24) y：复制选中的文本  (25) yy: 复制当前行  (26) p: 将复制的数据在光标的下一行/下一个位置粘贴  (27) u：撤销  (28) Ctrl + r：取消撤销  (29) 大于号 \u0026gt;：将选中的文本整体向右缩进一次  (30) 小于号 \u0026lt;：将选中的文本整体向左缩进一次  (31) :w 保存  (32) :w! 强制保存  (33) :q 退出  (34) :q! 强制退出  (35) :wq 保存并退出  (36) :set paste 设置成粘贴模式，取消代码自动缩进  (37) :set nopaste 取消粘贴模式，开启代码自动缩进  (38) :set nu 显示行号  (39) :set nonu 隐藏行号  (40) gg=G：将全文代码格式化  (41) :noh 关闭查找关键词高亮  (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令 异常处理：  每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。  如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：  (1) 找到正在打开该文件的程序，并退出  (2) 直接删掉该swp文件即可   shell脚本 https://www.acwing.com/file_system/file/content/whole/index/content/2855883/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  概论 注释 变量 默认变量 数组 expr命令 read命令 echo命令 printf命令 test命令与判断符号[] 判断语句 循环语句 函数 exit命令 文件重定向 引入外部脚本   ssh登录 https://www.acwing.com/file_system/file/content/whole/index/content/2898263/\nscp传文件 https://www.acwing.com/file_system/file/content/whole/index/content/2898266/\ngit https://www.acwing.com/file_system/file/content/whole/index/content/2932078/\nhttps://git.acwing.com/\n管道 https://www.acwing.com/file_system/file/content/whole/index/content/3030404/\n环境变量 https://www.acwing.com/file_system/file/content/whole/index/content/3030412/\n常用命令 https://www.acwing.com/file_system/file/content/whole/index/content/3030414/\n租云服务器和配置docker https://www.acwing.com/file_system/file/content/whole/index/content/3074146/\n","permalink":"https://kevinerr.github.io/posts/tech/linux/","summary":"Linux常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 打包并压缩文件:“tar -czvf 压缩包名.tar.gz 文件名” 解压并展开压缩包:“tar -xzvf","title":"linux"},{"content":"好东西\n设计模式的原则 1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。\n2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。\n5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。\n设计模式的分类 创建型模式 创建型模式简单来说就是用来创建对象的。\n单例模式：确保某一个类只有一个实例，并且提供一个全局访问点。 建造者模式： 用来创建复杂的复合对象。 工厂方法模式 ：让子类来决定要创建哪个对象。 抽象工厂模式：创建多个产品族中的产品对象。 原型模式：通过复制原型来创建新对象。clone 语法糖cloneable（想要和周杰伦一样的奶茶）\n行为型模式 行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。\n策略模式：封装不同的算法，算法之间能互相替换。 状态模式：根据不同的状态做出不同的行为。 责任连模式：将事件沿着链去处理。 观察者模式：状态发生改变时通知观察者，一对多的关系。 模板方法模式：定义一套流程模板，根据需要实现模板中的操作。 迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素。 迭代器模式：保存对象的状态，在需要时进行恢复。 访问者模式：稳定数据结构中，定义新的操作行为。 中介者模式：将网状结构转变为星型结构，所有行为都通过中介。 解释器模式：定义语法，并对其进行解释。 命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。\n结构型模式 结构型模式主要是用于处理类或者对象的组合。\n外观模式、桥接模式、组合模式、享元模式。 代理模式 ：控制客户端对对象的访问。 组合模式：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。 适配器模式：将原来不兼容的两个类融合在一起。 装饰者模式 ：为对象添加新功能。 享元模式：使用对象池来减少重复对象的创建。 外观模式 ：对外提供一个统一的接口用来访问子系统。 桥接模式：将两个能够独立变化的部分分离开来。\n单例 饿汉式：变量在申明时就初始化。将构造方法定义为private，必须getInstance才能获取唯一实例（即使单例不需要使用，也会在类加载后创建出来占用内存）\n工厂 简单工厂只需要和工厂打交道，需要啥告诉工厂就行。当产品过多时，工厂庞大。生成新的产品不行。 抽象工厂提取工厂接口。interface、implements（sql替换成access数据库就很简单）适用于增加同类工厂这样的横向扩展需求，不适用于新增功能这样的纵向需求。\n代理 策略 模板方法 观察者 适配器 责任链 建造者 创建过程稳定但配置多变 制造奶茶（是否+珍珠 去冰/冰/常温 全糖/半糖）\n","permalink":"https://kevinerr.github.io/posts/tech/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"好东西 设计模式的原则 1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修","title":"设计模式"},{"content":"并发编程基础 线程会带来额外的开销，如cpu调度\n继承thread类，重写run()方法，调用start()开启线程\nrun() 只有主线程一条执行路径；start()多条执行路径，主线程和子线程并行交替执行。\n实现runnable接口\n实现callable接口（FutureTask，可以通过get阻塞获取线程结果）\njava默认2个线程：main和gc\njava无法开启线程，只能调用底层c++，无法操作硬件\n并发：cpu一核（充分利用cpu资源） 并行：cpu多核\n线程有几个状态 1 2 3 4 5 6  NEW, //新生 RUNNABLE, BLOCKED, //阻塞 WAITING, TIMED_WAITING, //超时等待 TERMINATED; //终止   wait/sleep区别 1、wait()方法属于Object类,sleep()属于Thread类；\n2、wait()方法释放cpu给其他线程，自己让出资源进入等待池等待；sleep占用cpu，不让出资源；\n3、sleep()必须指定时间，wait()可以指定时间也可以不指定；sleep()时间到，线程处于临时阻塞或运行状态；\n4、wait()方法会释放持有的锁，不然其他线程不能进入同步方法或同步块，从而不能调用notify(),notifyAll()方法来唤醒线程，产生死锁，所以释放锁，可以执行其他线程，也可以唤醒自己，只是设置停止自己的时间时不确定的；sleep方法不会释放持有的锁，设置sleep的时间是确定的会按时执行的；\n5、wait()方法只能在同步方法或同步代码块中调用，否则会报illegalMonitorStateException异常，如果没有设定时间，使用notify()来唤醒；而sleep()能在任何地方调用，必须捕获异常；\n线程礼让 yield()  礼让线程,让当前正在执行的线程暂停,但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度,礼让不一定成功,看CPU心情  线程强制执行 join()  Join合并线程,待此线程执行完成后,在执行其他线程,其他线程阻塞 可以想象成插队  集合类 Vector：jdk1.0就有，加锁\nArrayList ：jdk1.2才有，不加锁\n1 2 3 4 5 6  Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;());   CopyOnWriteArrayList //修改副本，替换引用  HashSet 底层HashMap add时只添加key value是一个PRESENT的定值   线程池 三大方法，七大参数，四种拒绝策略\n程序的运行，本质：占用系统的资源 优化资源的使用 =》 池化技术\n线程池、连接池、内存池、对象池。。。 池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还我。\n三大方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //固定线程数池 core = max，都不可回收 ExecutorService executorService = Executors.newFixedThreadPool(5); //单例线程池 单线程线程池，后台从队列里获取任务，挨个执行 ExecutorService executorService1 = Executors.newSingleThreadExecutor(); //缓存线程数池 core是0，所有都可回收 ExecutorService executorService2 = Executors.newCachedThreadPool();  try {  for (int i = 0; i \u0026lt; 10; i++) {  executorService.execute(()-\u0026gt;{  System.out.println(Thread.currentThread().getName()+\u0026#34; ok\u0026#34;);  });  } } catch (Exception e) {  e.printStackTrace(); }finally{  //线程池用完，程序结束，关闭线程池  executorService1.shutdown(); }   七大参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  corePoolSize 核心线程数  //获取cpu核心 System.out.println(Runtime.getRuntime().availableProcessors()); ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(  2,// 核心线程数  Runtime.getRuntime().availableProcessors(),// 最大核心线程数  3,// 超时时间  TimeUnit.SECONDS,// 超时单位  new LinkedBlockingDeque\u0026lt;\u0026gt;(3),// 阻塞队列  Executors.defaultThreadFactory(),// 默认线程工厂，不用动它  new ThreadPoolExecutor.AbortPolicy() //线程池处理不过来就抛出异常(拒绝策略) ); try {  //最大承载：deque+max  for (int i = 0; i \u0026lt; 20; i++) {  threadPoolExecutor.execute(()-\u0026gt;{  System.out.println(Thread.currentThread().getName()+\u0026#34; ok\u0026#34;);  });  } } catch (Exception e) {  e.printStackTrace(); }finally{  //线程池用完，程序结束，关闭线程池  threadPoolExecutor.shutdown(); }   四种拒绝策略 1 2 3 4 5 6 7  new ThreadPoolExecutor.AbortPolicy() 线程池处理不过来就抛出异常  new ThreadPoolExecutor.CallerRunsPolicy() 哪来的去哪里；它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务  new ThreadPoolExecutor.DiscardPolicy() 队列满了，丢掉任务，不会抛异常  new ThreadPoolExecutor.DiscardOldestPolicy() 抛弃最老的    降低资源的消耗 提高响应的速度 方便管理  线程复用、可以控制最大并发数、管理线程\n1  System.out.println(Runtime.getRuntime().availableProcessors()); //h   最大线程数怎么定义：\n cpu 密集型 ：几核，就是几，可以保持cpu的效率最高 io 密集型 ：判断你程序中十分耗费io的线程  CompletableFuture异步编排 https://www.jianshu.com/p/934057982c25\nLock锁 公平锁和非公平锁 可重入锁（递归锁） 自旋锁 读写锁 synchronized和Lock锁区别 　1、首先synchronized是java内置关键字，Lock是个java类；\n　2、synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\n　3、synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n　4、用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\n　5、synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；\n　6、synchronized锁适合代码少量的同步问题，Lock锁适合大量同步的代码的同步问题。\n生产者消费者问题 所谓的生产者消费者问题，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架满的时候，消费者可以从货架上拿走商品，生产者此时等待货架的空位，这样不断的循环。那么在这个过程中，生产者和消费者是不直接接触的，所谓的‘货架’其实就是一个阻塞队列，生产者生产的产品不直接给消费者消费，而是仍给阻塞队列，这个阻塞队列就是来解决生产者消费者的强耦合的。就是生产者消费者问题。\n回忆 synchronized 关键字，它配合 Object 的 wait()、notify() 系列方法可以实现等待/通知模式。对于 Lock，通过 Condition 也可以实现等待/通知模式。Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。\nif只判断一次，虚假唤醒，一般使用while\n经典8锁问题 1、new this 调用的是这个对象，是一个具体的对象！ 2、static class 唯一的一个模板！ 在我们编写多线程程序得时候，只需要搞明白这个到底锁的是什么就不会出错了！\n安全类 并发下ArrayList是不安全的，Vector是安全的\n1 2 3 4 5 6  //解决办法 List\u0026lt;String\u0026gt; list2 = new Vector\u0026lt;\u0026gt;(); 使用synchronized List\u0026lt;String\u0026gt; list1 = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); List\u0026lt;String\u0026gt; list3 = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); //CopyOnWrite 写入时复制 COW计算机程序设计的一种优化策略，再写入时避免覆盖 //我们都知道Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。   Set不安全\n1 2 3  Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set1 = Collections.synchronizedSet(new HashSet\u0026lt;\u0026gt;()); Set\u0026lt;String\u0026gt; set2 = new CopyOnWriteArraySet\u0026lt;\u0026gt;();   HashSet的底层就是HashMap\nHashMap不安全\n1 2 3  Map\u0026lt;String,String\u0026gt; map= new HashMap\u0026lt;\u0026gt;(16,0.75); Map\u0026lt;String,String\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String,String\u0026gt; map1= new ConcurrentHashMap\u0026lt;\u0026gt;();   callable Callable 和 Runnable 的使用方法大同小异， 区别在于： 1.Callable 使用 call（） 方法， Runnable 使用 run() 方法 2.call() 可以返回值， 而 run()方法不能返回。 3.call() 可以抛出受检查的异常，比如ClassNotFoundException， 而run()不能抛出受检查的异常。\n通过FutureTask和Runnable 挂上关系\n三大常用辅助类 CountDownLatch（减法计数器） 说明： 一个线程等待其他线程执行完之后再执行，相当于加强版的join，在初始化CountDownLatch是需要设定计数器的数值（计数器数据不一定跟线程数相同，但是一定计数器的值一定是要大于等于线程数，一个线程中可以进行多次扣减。当计数器扣减至0时才可继续向下执行）\n举例说明： 比如LOL在游戏开始时需要玩家全部准备完毕之后才开始，开始游戏可以理解为“主线程”，玩家准备理解为“其他线程”，在“其他线程”没有准备完毕之前，“主线程时等待状态”，当“其他线程”准备完毕之后“主线程”就会执行下一步开始游戏的动作\n1 2 3  private static CountDownLatch countDownLatsh = new CountDownLatch(5); countDownLatsh.countDown(); countDownLatsh.await();   CyclicBarrier（加法计数器） 说明： 让一组线程到达某个屏障，然后被阻塞，一直到最后一个线程到达屏障，然后屏障开放，所有被阻塞的线程继续执行，计数器与线程数相等。 CyclicBarrier(int parties, Runnable barrierAction) 当时使用这个构造函数时，barrierAction定义的任务会执行\n集齐7科龙珠召唤神龙\n1 2  private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5); cyclicBarrier.await();   Semaphore（限流的时候用） 1 2 3  private static final Semaphore semaphore=new Semaphore(3); semaphore.acquire(); semaphore.release();   相当于os中的资源量，得到/释放\nReadWriteLock 假设有个数据对象拥有写方法与读方法，多线程环境中要想保证数据的安全，需对该对象的读写方法都要加入 synchronized同步块。这样任何线程在写入时，其它线程无法读取与改变数据；如果有线程在读取时，其他线程也无法读取或写入。这种方式在写入操作远大于读操作时，问题不大，而当读取远远大于写入时，会造成性能瓶颈，因为此种情况下读取操作是可以同时进行的，而加锁操作限制了数据的并发读取。\n​ ReadWriteLock解决了这个问题，当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据 。\n1 2 3 4 5 6 7  ReadWriteLock lock = new ReentrantReadWriteLock(); Lock read = lock.readLock(); Lock write = lock.writeLock(); write.lock(); write.unlock(); read.lock(); read.unlock();   独占锁（写锁）：一次只能被一个线程占有\n共享锁（读锁）：多个线程可以同时占有\nBlockingQueue（阻塞队列） 多线程并发处理，线程池\n   方式 抛出异常 有返回值，不会抛出异常 阻塞等待 超时等待     添加 add() offer() put() offer(object , long , TimeUnit)   移除 remove() poll() take() poll(long , TimeUnit)   检测队首元素 element() peek() - -    1  BlockingQueue\u0026lt;Object\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(3);   SynchronousQueue（同步队列） 没有容量\n进去一个元素必须等它出来才能再加一个元素\n1  SynchronousQueue\u0026lt;String\u0026gt; synchronousQueue = new SynchronousQueue\u0026lt;\u0026gt;();   四大函数式接口 新时代的程序员：lambda表达式、函数式接口、Stream流式计算、链式编程、异步调用\nlambda表达式 基本语法: (parameters) -\u0026gt; expression 或 (parameters) -\u0026gt;{ statements; }\nLambda表达式由三部分组成：\nparamaters：类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断。另外当只有一个推断类型时可以省略掉圆括号。 -\u0026gt;：可理解为“被用于”的意思 statements：可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不反回，这里的代码块块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。\n1 2 3 4 5 6 7 8 9 10  public static void main(String[] args) { // Function\u0026lt;String, String\u0026gt; function = new Function\u0026lt;String, String\u0026gt;() { // @Override // public String apply(String str) { // return str; // } // };  Function\u0026lt;String, String\u0026gt; function = (str)-\u0026gt;{return str;};  System.out.println(function.apply(\u0026#34;啦啦啦啦啦\u0026#34;)); }   函数式接口 如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 如果我们在某个接口上声明了 @FunctionalInterface 注解，那么编译器就会按照函数式接口的定义来要求该接口，这样如果有两个抽象方法，程序编译就会报错的。所以，从某种意义上来说，只要你保证你的接口中只有一个抽象方法，你可以不加这个注解。加上就会自动进行检测的，保证安全。Function函数式接口\nFunction 函数型接口 Function 函数型接口, 有一个输入参数，有一个输出\n1 2 3 4 5 6   public static void main(String[] args) {  //输出大写后的原字符串  Function\u0026lt;String, String\u0026gt; function = str -\u0026gt; str.toUpperCase();   System.out.println(function.apply(\u0026#34;abc\u0026#34;));  }   Predicate 断定型接口 有一个输入参数，返回值只能是 布尔值！\n1 2 3 4 5 6   public static void main(String[] args) {  //判断一个字符串是否为a开头  Predicate\u0026lt;String\u0026gt; predicate = s -\u0026gt; !s.isEmpty() \u0026amp;\u0026amp; s.charAt(0) == \u0026#39;a\u0026#39;;   System.out.println(predicate.test(\u0026#34;abc\u0026#34;));  }   Consumer 消费型接口 只有输入没有输出\n1 2 3 4 5 6   public static void main(String[] args) {  //输出一个大写字符串  Consumer\u0026lt;String\u0026gt; consumer = s -\u0026gt; System.out.println(s.toUpperCase());   consumer.accept(\u0026#34;abc\u0026#34;);  }   Supplier 供给型接口 没有参数，只有输出值\n1 2 3 4 5 6   public static void main(String[] args) {  //返回一个Demo对象  Supplier\u0026lt;Demo\u0026gt; supplier = () -\u0026gt; {return new Demo();};   System.out.println(supplier.get().hashCode());  }   Stream流式计算 存储交给集合，计算交给流\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * 题目要求：只用一行代码实现 * 现在有五个用户！筛选： * 1、ID必须是偶数 * 2、年龄必须大于23岁 * 3、用户名转化为大写字母 * 4、用户名字母倒着排序 * 5、只输出一个用户 */ public class Test {  public static void main(String[] args) {  User u1 = new User(1,\u0026#34;a\u0026#34;,21);  User u2 = new User(2,\u0026#34;b\u0026#34;,22);  User u3 = new User(3,\u0026#34;c\u0026#34;,23);  User u4 = new User(4,\u0026#34;d\u0026#34;,24);  User u5 = new User(5,\u0026#34;e\u0026#34;,25);  User u6 = new User(6,\u0026#34;f\u0026#34;,26);  //集合用来存储  List\u0026lt;User\u0026gt; list = Arrays.asList(u1, u2, u3, u4, u5,u6);  //使用stream计算  //lambda表达式、链式编程、函数式接口、Stream流式计算  list.stream()  .filter(u-\u0026gt;{return u.getId()%2 == 0;})  .filter(u-\u0026gt;{return u.getAge() \u0026gt; 23;})  .map(u-\u0026gt;{return u.getName().toUpperCase();})  .sorted((uu1,uu2)-\u0026gt;{return uu2.compareTo(uu1);})  .limit(1)  .forEach(System.out::println);  } }   Forkjoin Forkjoin类似于一个递归算法，可以将一系列大问题拆分成小问题，然后逐个解决。 其中有个工作窃取的概念，即一个线程处理完成任务以后会从另一个线程中获取其他线程的任务进行处理。 由于线程是一种双端队列，可以从底部进行窃取。\nJMM JMM：Java内存模型，不存在的东西，概念，约定！\nJMM同步约定\n线程加锁前，必须把共享变量刷回主存\n线程解锁前，必须读取主存的最新值到工作内存中\n加锁和解锁是同一把锁\nstore和write换一下位置\n对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。\n read 读取，作用于主内存把变量从主内存中读取到本本地内存。 load 加载，主要作用本地内存，把从主内存中读取的变量加载到本地内存的变量副本中 use 使用，主要作用本地内存，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。、 assign 赋值 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store 存储 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write 写入 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 lock 锁定 ：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock 解锁：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。  所以看似简单的通信其实是这八种状态来实现的。\n同时在Java内存模型中明确规定了要执行这些操作需要满足以下规则：\n 不允许read和load、store和write的操作单独出现。 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。  volatile https://www.cnblogs.com/dolphin0520/p/3920373.html\n单例模式 CAS ABA问题 ","permalink":"https://kevinerr.github.io/posts/tech/%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"并发编程基础 线程会带来额外的开销，如cpu调度 继承thread类，重写run()方法，调用start()开启线程 run() 只有主线程一条执行路径；s","title":"并发/多线程"},{"content":"基础语法  对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。  访问控制符 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\n面向对象 封装 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。\n只能通过规定的方法访问数据。隐藏类的实例细节，方便修改和实现。\n继承 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔） public class C implements A,B {}\n子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。\n多态 多态是同一个行为具有多个不同表现形式或形态的能力；消除类型之间的耦合关系。 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示： Java 重写(Override)与重载(Overload) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。\n方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 接口 类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。\n标记接口 public interface EventListener{} 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\n向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\n容器 ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。\n 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。  LinkedList 是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。\n 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。  HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。 HashSet 允许有 null 值。 HashSet 是无序的，即不会记录插入的顺序。 HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。\nHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。 HashMap 是无序的，即不会记录插入的顺序。\n谈谈ConcurrentHashMap1.7和1.8的不同实现 Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析\n异常 使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。 一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n声明自定义异常 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。\n泛型 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。\n反射Reflection 是一种间接操作目标对象的机制，核心是JVM在运行的时候才动态加载类，并且对于任意一个类，都能够知道这个类的所有属性和方法，调用方法/访问属性，不需要提前在编译期知道运行的对象是谁，他允许运行中的Java程序获取类的信息，并且可以操作类或对象内部属性.\nJava语言反射提供一种动态链接程序组件的多功能方法。它允许程序创建和控制任何类的对象(根据安全性限制)，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的方式与对象协作的库。例如，反射经常在持续存储对象为数据库、XML或其它外部格式的框架中使用。Java reflection 非常有用，它使类和数据结构能按名称动态检索相关信息，并允许在运行着的程序中操作这些信息。 一个类在内存中只有一个class对象\n一个类被加载后，类的整个结构都会被封装在class对象中\n只要元素类型和维度相等就是同一个class\n以下三种获取Class对象的方式有什么不同？ 1、new Object().getClass 2、Object.class 3、 Class.forName(\u0026ldquo;java.util.String\u0026rdquo;)\n（1）类名.class：JVM将使用类装载器，将类装入内存(前提是:类还没有装入内存)，不做类的初始化工作，返回Class的对象。 \u0026ndash;已知具体的类\n（2）Class.forName(\u0026ldquo;类名字符串\u0026rdquo;)：装入类，并做类的静态初始化，返回Class的对象。 \u0026ndash;已知一个类的全类名\n（3）实例对象.getClass()：对类进行静态初始化、非静态初始化；返回引用运行时真正所指的对象(子对象的引用会赋给父对象的引用变量中)所属的类的Class的对象。 \u0026ndash;已知某个类的实例\n注解Annotation I/O 图形化（Swing） Native JNI（Java Native Interface）Java本地接口\nnative是与C++联合开发的时候用的！java自己开发不用的！\n使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。\n native 是用做java 和其他语言（如c++）进行协作时用的 也就是native 后的函数的实现不是用java写的 既然都不是java，那就别管它的源代码了，呵呵  native的意思就是通知操作系统，这个函数你必须给我实现，因为我要使用。所以native关键字的函数都是操作系统实现的，java只能调用。\njava是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了\n","permalink":"https://kevinerr.github.io/posts/tech/java%E5%9F%BA%E7%A1%80/","summary":"基础语法 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个","title":"Java基础"},{"content":"SSH Struts+Spring+Hibernate\nSSM SpringMVC+Spring+Mybatis\nORM ORM就是对象关系匹配，是为了解决面向对象与关系数据库存在的互不匹配的问题。简单来说，就是把关系数据库中的数据转换成面向对象程序中的对象。 常用的ORM框架有Hibernate和MyBatis，也就是ssh组合和ssm组合中的h与m。\nSpring ide中ioc代码\nhttps://www.bilibili.com/video/BV1gW411W7wy?p=7\nhttps://liayun.blog.csdn.net/article/details/115053350\nSpring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\nSpring是一个轻量级的非入侵的控制反转、面向切片的框架\n我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .\n控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法\nIOC(控制反转) 通俗地讲，就是把原本需要程序员自己创建和维护的一大堆bean统统交由Spring管理。 也就是说，Spring将我们从盘根错节的依赖关系中解放了。当前对象如果需要依赖另一个对象，只要打一个@Autowired注解，Spring就会自动帮你安装上。 AOP(面向切面编程) AOP\n配置 别名\n1 2  \u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;userT\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt;   Bean的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt;  \u0026lt;!--  id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符  如果配置id,又配置了name,那么name是别名  name可以设置多个别名,可以用逗号,分号,空格隔开  如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;   class是bean的全限定名=包名+类名 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   import\n1  \u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt;   ","permalink":"https://kevinerr.github.io/posts/tech/spring/","summary":"SSH Struts+Spring+Hibernate SSM SpringMVC+Spring+Mybatis ORM ORM就是对象关系匹配，是为了解决面向对象与关系数据库存在的互不匹配的问题。简单来说，就是把关系数据库中的数据转换成面向对象程序中","title":"spring"},{"content":"Redis(remote dictionary server) 远程字典服务\n干什么 内存存储、持久化，内存中是断电即失，所以持久化很重要（rdb、aof）\n效率高，用于高速缓存\n发布订阅系统\n地图信息分析\n消息中间件\n特性 多样的数据类型\n持久化\n集群\n事务\n1 2 3 4 5 6 7 8  select 3 #选择数据库 DBSIZE #查看大小 flushdb #清空当前数据库 FLUSHALL #清空全部数据库 EXISTS name #是否存在key move name 1 #从0号移到1号 EXPIRE name 10 #10s过期 ttl name #查看还有多久过期   redis默认使用单线程，也支持多线程。多线程会产生cpu上下文切换\n5大数据类型 string（字符串）的类型 string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。\n实例 redis 127.0.0.1:6379\u0026gt; SET runoob \u0026ldquo;菜鸟教程\u0026rdquo; OK redis 127.0.0.1:6379\u0026gt; GET runoob\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  APPEND #追加字符串 STRLEN #字符串长度  incr #+1 decr #-1 INCRBY n#+n DECRBY n#-n  GETRANGE Key 0 3 #截取字符串[0,3] SETRANGE key 1 xx #替换指定位置的字符串  setex #设置过期时间 setnx #不存在就设置成功，存在则设置失败  mset #同时设置多个值 mget #同时获取多个值 msetnx #是一个原子操作，要么一起成功，要么一起失败  #设置一个对象 user:{id}:{filed} mset user:1:name zhangsan user:1:age 2 mset user:1:name user:1:age  getset #先get再set   应用\n 计数器 统计多单位的数量 粉丝数 对象缓存存储  hash（哈希） map\nRedis hash 是一个键值(key=\u0026gt;value)对集合。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n1 2 3 4 5 6 7  redis 127.0.0.1:6379\u0026gt; DEL runoob redis 127.0.0.1:6379\u0026gt; HMSET runoob field1 \u0026#34;Hello\u0026#34; field2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis 127.0.0.1:6379\u0026gt; HGET runoob field1 \u0026#34;Hello\u0026#34; redis 127.0.0.1:6379\u0026gt; HGET runoob field2 \u0026#34;World\u0026#34;   1 2 3 4 5 6 7 8 9 10 11 12  hset hget hmset hmget hgetall hdel #删除 hlen #长度 hexists hkeys #所有key hvals #所有value hincrby hsetnx   应用\nhash更适合对象的存储\nlist（列表） Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n1 2 3 4 5 6 7 8 9 10 11 12  redis 127.0.0.1:6379\u0026gt; DEL runoob redis 127.0.0.1:6379\u0026gt; lpush runoob redis (integer) 1 redis 127.0.0.1:6379\u0026gt; lpush runoob mongodb (integer) 2 redis 127.0.0.1:6379\u0026gt; lpush runoob rabbitmq (integer) 3 redis 127.0.0.1:6379\u0026gt; lrange runoob 0 10 1) \u0026#34;rabbitmq\u0026#34; 2) \u0026#34;mongodb\u0026#34; 3) \u0026#34;redis\u0026#34; redis 127.0.0.1:6379\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  LPUSH #将值插入列表头部 RPUSH #将值插入列表尾部  LPOP #移除列表的第一个元素 RPOP #移除列表的最后一个元素  lindex #通过下表获取列表的一个值 Llen #长度  lrange list 0 -1 #全部元素 lrem list 1 one #移除list集合中指定个数的value ltrim list 1 2 #通过下表截取指定的长度，list已经被改变了  rpoplpush #移除列表中最后一个元素，将它移动到新的列表中  linsert #将某个具体的value插入列中某个元素的前面或后面   应用\n队列 lpush rpop 栈 lpush lpop\nset（集合） Redis 的 Set 是 string 类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  redis 127.0.0.1:6379\u0026gt; DEL runoob redis 127.0.0.1:6379\u0026gt; sadd runoob redis (integer) 1 redis 127.0.0.1:6379\u0026gt; sadd runoob mongodb (integer) 1 redis 127.0.0.1:6379\u0026gt; sadd runoob rabbitmq (integer) 1 redis 127.0.0.1:6379\u0026gt; sadd runoob rabbitmq (integer) 0 redis 127.0.0.1:6379\u0026gt; smembers runoob  1) \u0026#34;redis\u0026#34; 2) \u0026#34;rabbitmq\u0026#34; 3) \u0026#34;mongodb\u0026#34;   1 2 3 4 5 6  sismember #判断一个值是否在集合中 scard #获取元素个数 srem #移除元素 srandmember #随机抽选出一个元素 spop #随机删除集合中的元素 smove #将一个指定的值移动到另一个set集合中   应用\n微博 b站共同关注（交集）\n1 2 3  SDIFF #差集 SINTER #交集 SUNION #并集   zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\n1 2 3 4 5 6 7 8 9 10 11 12 13  redis 127.0.0.1:6379\u0026gt; DEL runoob redis 127.0.0.1:6379\u0026gt; zadd runoob 0 redis (integer) 1 redis 127.0.0.1:6379\u0026gt; zadd runoob 0 mongodb (integer) 1 redis 127.0.0.1:6379\u0026gt; zadd runoob 0 rabbitmq (integer) 1 redis 127.0.0.1:6379\u0026gt; zadd runoob 0 rabbitmq (integer) 0 redis 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE runoob 0 1000 1) \u0026#34;mongodb\u0026#34; 2) \u0026#34;rabbitmq\u0026#34; 3) \u0026#34;redis\u0026#34;   1 2 3 4 5  ZRANGEBYSCORE #小到大 ZREVRANGEBYSCORE #大到小 zrange zrem zcard   应用\n排行榜\n普通消息，重要消息\n三种特殊数据类型 geospatial 地理位置 1 2 3 4 5 6 7 8 9 10  #添加地理位置 下载城市数据 java程序一次性导入 经度（-180-180）纬度（-85-85） 名称 geoadd china:city 116.40 39.90 beijing geoadd china:city 112.47 31.23 shanghai geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shengzhen getpos china:city beijing #获取指定的经度和维度 getdist china:city beijing shanghai km #获取2地的直线距离 georadius china:city 110 30 1000 km withdist withcoord count 2 #找附近的人，获取指定数量的人 georadiusbymember china:city beijing 1000 km #找出指定元素周围的其他元素 geohash #将二维的经纬度转化为一维的字符串   底层原理是zset，可以用zset命令操作\nzrange china:city 0 -1\nhyperloglog 基数：不重复的元素\n网页的UV（一个人访问一个网站多次，只算一个人）\n传统：用set保存用户id ，保存了大量的id，但目的是计数\n1 2 3 4  pfadd mykey1 a b c d e pfadd mykey2 g h j k l e pfcount mykey1 pfmerge mykey3 mykey1 mykey2   优点：占用内存是一定的 12kb。0.81%的错误率！统计UV可以忽略不计\nbitmaps 位存储\n统计疫情感染人数： 0 1 0 1 0\n统计用户信息（是否活跃） 用户打卡。两个状态的\n1 2 3 4 5 6 7 8 9  setbit sign 0 1 setbit sign 1 1 setbit sign 2 1 setbit sign 3 1 setbit sign 4 1 setbit sign 5 1 setbit sign 6 0 #周一-周日的打卡 getbit sign 1 bitcount sign #统计打卡记录   SpringBoot springboot2.x后，原来使用的jedis被替换为了lettuce\njedis：采用的直连，多个线程操作的话，不安全，如果需要避免不安全，需要使用jedis pool连接；BIO模式\nlettuce：采用netty，实例可以在多个线程中共享 NIO模式\n1 2 3 4 5 6 7  RedisTemplate.opsForValue().set(key, value);  //封装一下 @Override  public void set(String key, String value) {  stringRedisTemplate.opsForValue().set(key, value);  }   事务 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。\nRedis没有隔离级别的概念。\nRedis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：\n 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。  一个事务从开始到执行会经历以下三个阶段：\n 开始事务。 命令入队。 执行事务。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  redis 127.0.0.1:6379\u0026gt; MULTI OK  redis 127.0.0.1:6379\u0026gt; SET book-name \u0026#34;Mastering C++ in 21 days\u0026#34; QUEUED  redis 127.0.0.1:6379\u0026gt; GET book-name QUEUED  redis 127.0.0.1:6379\u0026gt; SADD tag \u0026#34;C++\u0026#34; \u0026#34;Programming\u0026#34; \u0026#34;Mastering Series\u0026#34; QUEUED  redis 127.0.0.1:6379\u0026gt; SMEMBERS tag QUEUED  redis 127.0.0.1:6379\u0026gt; EXEC 1) OK 2) \u0026#34;Mastering C++ in 21 days\u0026#34; 3) (integer) 3 4) 1) \u0026#34;Mastering Series\u0026#34;  2) \u0026#34;C++\u0026#34;  3) \u0026#34;Programming\u0026#34; ```  discard #取消事务 #命令写错了全不会执行，  ## 消息通知 [消息通知]（https://waterwang.blog.csdn.net/article/details/113768448)  ## 管道 Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤： * 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。 * 服务端处理命令，并将结果返回给客户端。  ### Redis 管道技术 Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。 管道技术最显著的优势是提高了 redis 服务的性能。   $(echo -en \u0026ldquo;PING\\r\\n SET runoobkey redis\\r\\nGET runoobkey\\r\\nINCR visitor\\r\\nINCR visitor\\r\\nINCR visitor\\r\\n\u0026rdquo;; sleep 10) | nc localhost 6379\n+PONG +OK redis :1 :2 :3``` 以上实例中我们通过使用 PING 命令查看redis服务是否可用， 之后我们设置了 runoobkey 的值为 redis，然后我们获取 runoobkey 的值并使得 visitor 自增 3 次。 在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应\n悲观锁、乐观锁version\n使用watch 可以当做redis的乐观锁操作\n持久化 redis是内存数据库，如果不将内存中的数据保存到硬盘，数据将丢失。\nrdb（redis database） config get dir 得到dump.rdb的存放位置/usr/local/bin 只需要放在此目录下，启动就会自动扫描其中的数据\n快照形式是直接把内存中的数据保存到一个 dump 文件中，定时保存，保存策略。\n当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处就是可以 copy-on-write。\nRedis默认情况下，是快照 RDB 的持久化方式，将内存中的数据以快照的方式写入二进制文件中，默认的文件名是 dump.rdb 。当然我们也可以手动执行 save 或者 bgsave（异步）做快照。\nRDB 的优点:\n这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）。\nRDB 的缺点:\n如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， **一旦发生故障停机， 你就可能**会丢****失好几分钟的数据。\n触发机制：\n save的规则满足的情况下 执行flushall命令 退出redis时  aof（append only file） 使用 AOF 做持久化，每一个写命令都通过write函数追加到 appendonly.aof 中,配置方式：启动 AOF 持久化的方式\n1 2 3 4 5 6 7  appendfsync yes appendfsync always #每次有数据修改发生时都会写入AOF文件。 appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。  redis-check-aof --fix appendonly.aof #修复文件   AOF 的优点\n使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。\nAOF 的缺点\n对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关 闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。\n如果aof文件大于64m，将fork一个新进程重写。\n二者的区别 RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。\nAOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。\nRDB 和 AOF ,我应该用哪一个？\n 如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久。 AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低 Redis 的性能，不知道你是否可以接受。  数据库备份和灾难恢复：定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。\nRedis 支持同时开启 RDB 和 AOF,系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。\nRedis 发布订阅 1 2 3 4 5 6  redis 127.0.0.1:6379**\u0026gt;** SUBSCRIBE runoobChat  Reading messages... **(**press Ctrl-C to quit**)** 1**)** \u0026#34;subscribe\u0026#34; 2**)** \u0026#34;redisChat\u0026#34; 3**)** **(**integer**)** 1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  redis 127.0.0.1:6379\u0026gt; PUBLISH runoobChat \u0026#34;Redis PUBLISH test\u0026#34;  (integer) 1  redis 127.0.0.1:6379\u0026gt; PUBLISH runoobChat \u0026#34;Learn redis by runoob.com\u0026#34;  (integer) 1  \\# 订阅者的客户端会显示如下消息  1) \u0026#34;message\u0026#34; 2) \u0026#34;runoobChat\u0026#34; 3) \u0026#34;Redis PUBLISH test\u0026#34;  1) \u0026#34;message\u0026#34; 2) \u0026#34;runoobChat\u0026#34; 3) \u0026#34;Learn redis by runoob.com\u0026#34;   Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，藉此加深对Redis的理解。\nRedis通过publish、subscribe和psubscribe等命令实现发布和订阅功能。\n微信：\n通过subscribe命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。subscribe命令的关键，就是将客户端添加到给定channel的的订阅链表中。\n通过publish命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。\nPub/Sub从字面上理解就是发布(Publish)与订阅(Subscribe)，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。\n使用场景：\n1.实时消息系统\n2.实时聊天(频道当作聊天室，将信息回显给所有人即可)\n3.订阅，关注系统都是可以的\n稍微复杂的场景我们就会使用消息中间件MQ。\nRedis主从复制 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。master写，slave读。读写分离\n作用：\n数据冗余，热备份，持久化之外的一种数据冗余方式\n故障恢复\n负载均衡\n高可用基石\n1 2 3  info replication  slaveof 127.0.0.1 6379 #真实的应该在从机的conf文件里配置，这个方法重启这个从机就会重新变回主机   从机不能写\n全量同步 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。\n增量同步 Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。\nRedis主从同步策略 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。\n注意点 如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。\n哨兵模式（sentinel） 哨兵是Redis的一种运行模式，它专注于对Redis实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个Redis系统的可用性。结合Redis的官方文档，可以知道Redis哨兵具备的能力有如下几个：\n  监控（Monitoring）：持续监控Redis主节点、从节点是否处于预期的工作状态。\n  通知（Notification）：哨兵可以把Redis实例的运行故障信息通过API通知监控系统或者其他应用程序。\n  自动故障恢复（Automatic failover）：当主节点运行故障时，哨兵会启动自动故障恢复流程：某个从节点会升级为主节点，其他从节点会使用新的主节点进行主从复制，通知客户端使用新的主节点进行。\n  配置中心（Configuration provider）：哨兵可以作为客户端服务发现的授权源，客户端连接到哨兵请求给定服务的Redis主节点地址。如果发生故障转移，哨兵会通知新的地址。这里要注意：哨兵并不是Redis代理，只是为客户端提供了Redis主从节点的地址信息。\n  准备三个redis配置文件，对应Redis的一主二从，文件名称及内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # redis-6379.conf* port 6379 daemonize yes pidfile /var/run/redis-6379.pid logfile \u0026#34;6379.log\u0026#34; dir \u0026#34;/Users/eleme/raysonxin/docker/redis-docker/log\u0026#34; dbfilename dump-6379.rdb  *# redis-6380.conf* port 6380 daemonize yes pidfile /var/run/redis-6380.pid logfile \u0026#34;6380.log\u0026#34; dir \u0026#34;/Users/eleme/raysonxin/docker/redis-docker/log\u0026#34; dbfilename dump-6380.rdb slaveof 127.0.0.1 6379  *# redis-6381.conf* port 6381 daemonize yes pidfile /var/run/redis-6381.pid logfile \u0026#34;6381.log\u0026#34; dir \u0026#34;/Users/eleme/raysonxin/docker/redis-docker/log\u0026#34; dbfilename dump-6381.rdb slaveof 127.0.0.1 6379   准备三个Redis Sentinel配置文件，作为三个监控节点，文件及内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  # sentinel-26379.conf* port 26379 daemonize yes dir \u0026#34;/Users/eleme/raysonxin/docker/redis-docker/log\u0026#34; logfile \u0026#34;26379.log\u0026#34; *# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。* sentinel monitor mymaster 127.0.0.1 6379 2 *# 判断主节点时间* sentinel down-after-milliseconds mymaster 10000 sentinel parallel-syncs mymaster 1 sentinel failover-timeout mymaster 180000  *# sentinel-26380.conf* port 26380 daemonize yes dir \u0026#34;/Users/eleme/raysonxin/docker/redis-docker/log\u0026#34; logfile \u0026#34;26380.log\u0026#34; *# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。* sentinel monitor mymaster 127.0.0.1 6379 2 *# 判断主节点时间* sentinel down-after-milliseconds mymaster 10000 sentinel parallel-syncs mymaster 1 sentinel failover-timeout mymaster 180000  *# sentinel-26381.conf* port 26381 daemonize yes dir \u0026#34;/Users/eleme/raysonxin/docker/redis-docker/log\u0026#34; logfile \u0026#34;26381.log\u0026#34; *# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。* sentinel monitor mymaster 127.0.0.1 6379 2 *# 判断主节点时间* sentinel down-after-milliseconds mymaster 10000 sentinel parallel-syncs mymaster 1 sentinel failover-timeout mymaster 180000   依次启动三个Redis Server，命令如下：\n1 2 3  redis-server conf/redis-6379.conf redis-server conf/redis-6380.conf redis-server conf/redis-6381.conf   依次启动三个Redis Sentinel，命令如下：\n1 2 3  redis-sentinel conf/redis-26379.conf redis-sentinel conf/redis-26380.conf redis-sentinel conf/redis-26381.conf   Redis缓存穿透和雪崩（服务器的高可用问题） 缓存穿透（查不到） 缓存穿透概念：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。\n缓存穿透方案：最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n缓存击穿（查太多） 缓存击穿概念：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。\n缓存击穿方案：\n  用互斥锁(mutex key)\n加锁保证只有一个线程进去db\n  业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。\nSETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。x\n缓存雪崩 缓存雪崩概念：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。缓存集体过期或redis宕机\n双十一：停掉一些服务\n缓存雪崩方案：缓存失效时的雪崩效应对底层系统的冲击非常可怕！大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n","permalink":"https://kevinerr.github.io/posts/tech/redis/","summary":"Redis(remote dictionary server) 远程字典服务 干什么 内存存储、持久化，内存中是断电即失，所以持久化很重要（rdb、aof） 效率高，用于高速缓存 发布订阅系统 地图信息分析 消","title":"redis学习笔记"},{"content":"面试问题 谈谈对JVM的理解？java8虚拟机和以前有什么区别\n什么是OOM？什么是栈溢出StackOverFlowError？\nJVM的常用调优参数有哪些？\n内存快照如何抓取，怎么分析Dump文件？\n谈谈JVM中，类加载器的认识？\n在一个项目中突然出现了OOM故障，该怎么排除？\nJVM的内存模型和分区-详细到每个区放什么？\n堆里面的分区有哪些？有什么特点？\nGC的算法有哪些？\n轻GC和重GC\n1 2 3 4 5  首先 三者之间存在包含关系  JVM + 核心类库 = JRE  JRE + java开发工具（javac.exe/jar.exe) = JDK   什么是JVM？ Java Virtual Machine 即Java虚拟机\n我们知道Java语言有一个独特的优点就是可以跨平台\n像其它语言，比如C，我们要针对不同操作系统windos，mac……各出一套应用程序\n而Java则可以做到一个软件在任何的操作系统中都能执行，这就是JVM的功劳\n如下图 图片来自高新强老师JAVA课程 本来我们编写的Java代码计算机还是不认识的，但是我们在每一个操作系统上都会配置一个与之相对应的JVM，会帮我们把我们的Java代码翻译成对应操作系统可以识别的内容。\nJVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。\nJava语言中的反编译一般指将class文件转换成java文件。\n所以说我们在第一次写Java程序时都要先把JVM给装好。\n什么是JRE？ Java Runtime Environment 即Java运行环境\nJVM + 核心类库 = JRE\n刚才不是说只需要装JVM吗？那这个JRE是个什么鬼东西？\n是因为只有JVM不能运行，它还需要核心类库，才能保证Java运行\n由于JRE包含JVM 因此我们只要直接安装JRE 就顺便把JVM安装了\n图片来自高新强老师JAVA课程\n什么是JDK? Java Development Kit 即Java开发工具包\nJRE + java开发工具（javac.exe/jar.exe) = JDK\n前面不是说安装了JRE以后,Java程序就可以运行了吗?那为啥子还要安装这个JDK?\n这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding\n由于JDK包含JRE 因此我们只需要安装JDK就都有了\n类加载机制 类装载器（ClassLoader）（用来装载.class文件并初始化)\n执行引擎（执行字节码，或者执行本地方法） 运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈)\n堆（Heap） 它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。\n元空间逻辑上存在，物理上不存在，不放在虚拟机内存，而存储在本地内存中\n运行时常量池（Runtime Constant Pool） 存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。\n本地方法堆栈（Native Method Stacks） JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。\nPC寄存器 PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。\n方法区 方法区：static、final、Class、常量池\n不止是存“方法”，而是存储整个 class文件的信息，JVM运行时，类加载器子系统将会提取 class文件里面的类信息，并将其存放在方法区中。例如类的名称、类的类型（枚举、类、接口）、字段、方法等等。\n方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。\n栈 栈：栈内存，主管程序的运行，生命周期和线程同步\n 线程结束，栈内存就释放，对于栈来说，不存在垃圾回收问题 一旦线程结束，栈就over 栈：JVM栈中存放的为当前线程中局部8大基本类型（boolean、char、byte、short、int、long、float、double）、对象引用、实例的方法、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。 栈的运行原理：栈帧 栈满了：StackOverFlowError 栈+堆+方法区：交互关系 JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈  双亲委派机制 工作原理：\n1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达项层的启动类加载器；\n3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。\n作用：\n1）避免核心API被篡改\n2）避免类的重复加载\n1 2 3  AppClassLoader ExtClassLoader BootstrapClassloader #java获取不到，因为底层是c/c++   字节码执行机制 GC垃圾回收 GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停\n（1）对新生代的对象的收集称为minor GC； （2）对旧生代的对象的收集称为Full GC； （3）程序中主动调用System.gc()强制执行的GC为Full GC。\n不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：\n（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收） （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC） （3）弱引用：在GC时一定会被GC回收 （4）虚引用：由于虚引用只是用来得知对象是否被GC\n不同的区\n垃圾收集算法 标记-清除算法 适用场合：\n 存活对象较多的情况下比较高效 适用于年老代（即旧生代）  缺点：\n 容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收 扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）  复制算法 适用场合：\n 存活对象较少的情况下比较高效 扫描了整个空间一次（标记存活对象并复制移动） 适用于年轻代（即新生代）：基本上98%的对象是\u0026quot;朝生夕死\u0026quot;的，存活下来的会很少  缺点：\n 需要一块儿空的内存空间 需要复制移动对象  标记-整理算法 标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。\n首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。\n分代收集算法 分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。\n在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率高，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。\n步骤：\n 当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，每次Minor GC，存活下来的对象年龄加+1 那什么时候会进入老年代呢？从上面看到，如果对象在GC过程中没有被回收，那么它的对象年龄（Age）会不断的增加，对象在Survivor区每熬过一个Minor GC，年龄就增加1岁，当它的年龄到达一定的程度（默认为15岁），就会被移动到老年代，这个年龄阀值可以通过-XX:MaxTenuringThreshold设置。  谁空谁是to\n大对象直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。\n详情 垃圾收集算法是方法论，垃圾收集器是具体实现。JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大，这里只看HotSpot虚拟机。\nJVM性能监控与故障定位 JVM调优 **对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。**1.Full GC\n会对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少Full GC的次数。\n2.导致Full GC的原因\n1)*年老代（Tenured）被写满*\n调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。\n2)持久代Pemanet Generation空间不足\n增大Perm Gen空间，避免太多静态对象 ， 控制好新生代和旧生代的比例\n3)System.gc()被显示调用\n垃圾回收不要手动触发，尽量依靠JVM自身的机制\n1.监控GC的状态\n使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。\n举一个例子： 系统崩溃前的一些现象：\n 每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC 年老代的内存越来越大并且每次FullGC后年老代没有内存被释放  之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。\n4.分析结果，判断是否需要优化\n如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。\n注：如果满足下面的指标，则一般不需要进行GC：\n Minor GC执行时间不到50ms； Minor GC执行不频繁，约10秒一次； Full GC执行时间不到1s； Full GC执行频率不算频繁，不低于10分钟1次；  5.调整GC类型和内存分配\n如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。\n6.不断的分析和调整\n通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。\nJVM调优参数参考\n1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;\n2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。\n比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。\n3.年轻代和年老代设置多大才算合理\n1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC\n2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率\n如何选择应该依赖应用程序对象生命周期的分布情况： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。\n在抉择时应该根 据以下两点：\n（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。\n（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。\n4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。\n5.线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。\n理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。\nJMM java 内存模型\n","permalink":"https://kevinerr.github.io/posts/tech/jvm/","summary":"面试问题 谈谈对JVM的理解？java8虚拟机和以前有什么区别 什么是OOM？什么是栈溢出StackOverFlowError？ JVM的常用调优","title":"jvm"},{"content":"1 2 3 4 5 6 7  pdflatex test.tex #不允许有中文 xelatex test.tex #通用 texdoc #打开文档 texdoc ctex texdoc lshort-zh-ch texdoc symbols-a4 texdoc beame   ","permalink":"https://kevinerr.github.io/posts/tech/latex/","summary":"1 2 3 4 5 6 7 pdflatex test.tex #不允许有中文 xelatex test.tex #通用 texdoc #打开文档 texdoc ctex texdoc lshort-zh-ch texdoc symbols-a4 texdoc beame","title":""},{"content":"","permalink":"https://kevinerr.github.io/tags/","summary":"","title":"🔍搜索"},{"content":"Talk is cheap,show me the code 职业：五线城市程序员\n运动：篮球、羽毛球、乒乓球、游泳、跑步\n游戏：LOL\n","permalink":"https://kevinerr.github.io/about/","summary":"Talk is cheap,show me the code 职业：五线城市程序员 运动：篮球、羽毛球、乒乓球、游泳、跑步 游戏：LOL","title":"🙋🏻‍♂️关于"},{"content":"\rSulv’s Blog\r一个记录技术、阅读、生活的博客\r\r\r\r👉友链格式 名称： hkh\u0026rsquo;s blog\n网址：\n图标：\n描述：\n👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://kevinerr.github.io/links/","summary":"Sulv’s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： hkh\u0026rsquo;s blog 网址： 图标： 描述： 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广","title":"🤝友情链接"}]