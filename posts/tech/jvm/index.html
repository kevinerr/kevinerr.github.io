<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>jvm | hkh&#39;s Blog</title>
<meta name="keywords" content="java, jvm" />
<meta name="description" content="面试问题 谈谈对JVM的理解？java8虚拟机和以前有什么区别 什么是OOM？什么是栈溢出StackOverFlowError？ JVM的常用调优">
<meta name="author" content="
作者:&nbsp;kevin">
<link rel="canonical" href="https://kevinerr.github.io/posts/tech/jvm/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7724ad4800b622e9e86a37940cdc71441089d486cd46f35de38fdd833dd93d2f.css" integrity="sha256-dyStSAC2IunoajeUDNxxRBCJ1IbNRvNd44/dgz3ZPS8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://kevinerr.github.io/img/Q.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://kevinerr.github.io/img/Q.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://kevinerr.github.io/img/Q.jpg">
<link rel="apple-touch-icon" href="https://kevinerr.github.io/Q.jpg">
<link rel="mask-icon" href="https://kevinerr.github.io/Q.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.94.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="jvm" />
<meta property="og:description" content="面试问题 谈谈对JVM的理解？java8虚拟机和以前有什么区别 什么是OOM？什么是栈溢出StackOverFlowError？ JVM的常用调优" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kevinerr.github.io/posts/tech/jvm/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-15T19:13:13&#43;00:00" />
<meta property="article:modified_time" content="2021-03-15T19:13:13&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="jvm"/>
<meta name="twitter:description" content="面试问题 谈谈对JVM的理解？java8虚拟机和以前有什么区别 什么是OOM？什么是栈溢出StackOverFlowError？ JVM的常用调优"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://kevinerr.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻技术",
      "item": "https://kevinerr.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "jvm",
      "item": "https://kevinerr.github.io/posts/tech/jvm/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "jvm",
  "name": "jvm",
  "description": "面试问题 谈谈对JVM的理解？java8虚拟机和以前有什么区别 什么是OOM？什么是栈溢出StackOverFlowError？ JVM的常用调优",
  "keywords": [
    "java", "jvm"
  ],
  "articleBody": "面试问题 谈谈对JVM的理解？java8虚拟机和以前有什么区别\n什么是OOM？什么是栈溢出StackOverFlowError？\nJVM的常用调优参数有哪些？\n内存快照如何抓取，怎么分析Dump文件？\n谈谈JVM中，类加载器的认识？\n在一个项目中突然出现了OOM故障，该怎么排除？\nJVM的内存模型和分区-详细到每个区放什么？\n堆里面的分区有哪些？有什么特点？\nGC的算法有哪些？\n轻GC和重GC\n1 2 3 4 5  首先 三者之间存在包含关系  JVM + 核心类库 = JRE  JRE + java开发工具（javac.exe/jar.exe) = JDK   什么是JVM？ Java Virtual Machine 即Java虚拟机\n我们知道Java语言有一个独特的优点就是可以跨平台\n像其它语言，比如C，我们要针对不同操作系统windos，mac……各出一套应用程序\n而Java则可以做到一个软件在任何的操作系统中都能执行，这就是JVM的功劳\n如下图 图片来自高新强老师JAVA课程 本来我们编写的Java代码计算机还是不认识的，但是我们在每一个操作系统上都会配置一个与之相对应的JVM，会帮我们把我们的Java代码翻译成对应操作系统可以识别的内容。\nJVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。\nJava语言中的反编译一般指将class文件转换成java文件。\n所以说我们在第一次写Java程序时都要先把JVM给装好。\n什么是JRE？ Java Runtime Environment 即Java运行环境\nJVM + 核心类库 = JRE\n刚才不是说只需要装JVM吗？那这个JRE是个什么鬼东西？\n是因为只有JVM不能运行，它还需要核心类库，才能保证Java运行\n由于JRE包含JVM 因此我们只要直接安装JRE 就顺便把JVM安装了\n图片来自高新强老师JAVA课程\n什么是JDK? Java Development Kit 即Java开发工具包\nJRE + java开发工具（javac.exe/jar.exe) = JDK\n前面不是说安装了JRE以后,Java程序就可以运行了吗?那为啥子还要安装这个JDK?\n这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding\n由于JDK包含JRE 因此我们只需要安装JDK就都有了\n类加载机制 类装载器（ClassLoader）（用来装载.class文件并初始化)\n执行引擎（执行字节码，或者执行本地方法） 运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈)\n堆（Heap） 它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。\n元空间逻辑上存在，物理上不存在，不放在虚拟机内存，而存储在本地内存中\n运行时常量池（Runtime Constant Pool） 存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。\n本地方法堆栈（Native Method Stacks） JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。\nPC寄存器 PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。\n方法区 方法区：static、final、Class、常量池\n不止是存“方法”，而是存储整个 class文件的信息，JVM运行时，类加载器子系统将会提取 class文件里面的类信息，并将其存放在方法区中。例如类的名称、类的类型（枚举、类、接口）、字段、方法等等。\n方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。\n栈 栈：栈内存，主管程序的运行，生命周期和线程同步\n 线程结束，栈内存就释放，对于栈来说，不存在垃圾回收问题 一旦线程结束，栈就over 栈：JVM栈中存放的为当前线程中局部8大基本类型（boolean、char、byte、short、int、long、float、double）、对象引用、实例的方法、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。 栈的运行原理：栈帧 栈满了：StackOverFlowError 栈+堆+方法区：交互关系 JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈  双亲委派机制 工作原理：\n1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达项层的启动类加载器；\n3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。\n作用：\n1）避免核心API被篡改\n2）避免类的重复加载\n1 2 3  AppClassLoader ExtClassLoader BootstrapClassloader #java获取不到，因为底层是c/c++   字节码执行机制 GC垃圾回收 GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停\n（1）对新生代的对象的收集称为minor GC； （2）对旧生代的对象的收集称为Full GC； （3）程序中主动调用System.gc()强制执行的GC为Full GC。\n不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：\n（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收） （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC） （3）弱引用：在GC时一定会被GC回收 （4）虚引用：由于虚引用只是用来得知对象是否被GC\n不同的区\n垃圾收集算法 标记-清除算法 适用场合：\n 存活对象较多的情况下比较高效 适用于年老代（即旧生代）  缺点：\n 容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收 扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）  复制算法 适用场合：\n 存活对象较少的情况下比较高效 扫描了整个空间一次（标记存活对象并复制移动） 适用于年轻代（即新生代）：基本上98%的对象是\"朝生夕死\"的，存活下来的会很少  缺点：\n 需要一块儿空的内存空间 需要复制移动对象  标记-整理算法 标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。\n首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。\n分代收集算法 分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。\n在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率高，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。\n步骤：\n 当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，每次Minor GC，存活下来的对象年龄加+1 那什么时候会进入老年代呢？从上面看到，如果对象在GC过程中没有被回收，那么它的对象年龄（Age）会不断的增加，对象在Survivor区每熬过一个Minor GC，年龄就增加1岁，当它的年龄到达一定的程度（默认为15岁），就会被移动到老年代，这个年龄阀值可以通过-XX:MaxTenuringThreshold设置。  谁空谁是to\n大对象直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。\n详情 垃圾收集算法是方法论，垃圾收集器是具体实现。JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大，这里只看HotSpot虚拟机。\nJVM性能监控与故障定位 JVM调优 **对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。**1.Full GC\n会对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少Full GC的次数。\n2.导致Full GC的原因\n1)*年老代（Tenured）被写满*\n调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。\n2)持久代Pemanet Generation空间不足\n增大Perm Gen空间，避免太多静态对象 ， 控制好新生代和旧生代的比例\n3)System.gc()被显示调用\n垃圾回收不要手动触发，尽量依靠JVM自身的机制\n1.监控GC的状态\n使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。\n举一个例子： 系统崩溃前的一些现象：\n 每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC 年老代的内存越来越大并且每次FullGC后年老代没有内存被释放  之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。\n4.分析结果，判断是否需要优化\n如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。\n注：如果满足下面的指标，则一般不需要进行GC：\n Minor GC执行时间不到50ms； Minor GC执行不频繁，约10秒一次； Full GC执行时间不到1s； Full GC执行频率不算频繁，不低于10分钟1次；  5.调整GC类型和内存分配\n如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。\n6.不断的分析和调整\n通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。\nJVM调优参数参考\n1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;\n2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。\n比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。\n3.年轻代和年老代设置多大才算合理\n1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC\n2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率\n如何选择应该依赖应用程序对象生命周期的分布情况： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。\n在抉择时应该根 据以下两点：\n（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。\n（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。\n4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。\n5.线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。\n理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。\nJMM java 内存模型\n",
  "wordCount" : "5550",
  "inLanguage": "en",
  "datePublished": "2021-03-15T19:13:13Z",
  "dateModified": "2021-03-15T19:13:13Z",
  "author":{
    "@type": "Person",
    "name": "kevin"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kevinerr.github.io/posts/tech/jvm/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "hkh's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kevinerr.github.io/img/Q.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kevinerr.github.io/" accesskey="h" title="hkh&#39;s Blog (Alt + H)">hkh&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kevinerr.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://kevinerr.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://kevinerr.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://kevinerr.github.io/archives" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://kevinerr.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://kevinerr.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://kevinerr.github.io/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kevinerr.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://kevinerr.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://kevinerr.github.io/posts/tech/">👨🏻‍💻技术</a></div>
    <h1 class="post-title">
      jvm
    </h1>
    <div class="post-meta">










创建:&nbsp;<span title='2021-03-15 19:13:13 +0000 UTC'>2021-03-15</span>&nbsp;|&nbsp;更新:&nbsp;2021-03-15&nbsp;|&nbsp;字数:&nbsp;5550字&nbsp;|&nbsp;时长: 12分钟&nbsp;|&nbsp;
作者:&nbsp;kevin

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98" aria-label="面试问题">面试问题</a></li>
                    <li>
                        <a href="#%e4%bb%80%e4%b9%88%e6%98%afjvm" aria-label="什么是JVM？">什么是JVM？</a></li>
                    <li>
                        <a href="#%e4%bb%80%e4%b9%88%e6%98%afjre" aria-label="什么是JRE？">什么是JRE？</a></li>
                    <li>
                        <a href="#%e4%bb%80%e4%b9%88%e6%98%afjdk" aria-label="什么是JDK?">什么是JDK?</a></li>
                    <li>
                        <a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6" aria-label="类加载机制">类加载机制</a><ul>
                            
                    <li>
                        <a href="#%e5%a0%86heap" aria-label="堆（Heap）">堆（Heap）</a></li>
                    <li>
                        <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0runtime-constant-pool" aria-label="运行时常量池（Runtime Constant Pool）">运行时常量池（Runtime Constant Pool）</a></li>
                    <li>
                        <a href="#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e5%a0%86%e6%a0%88native-method-stacks" aria-label="本地方法堆栈（Native Method Stacks）">本地方法堆栈（Native Method Stacks）</a></li>
                    <li>
                        <a href="#pc%e5%af%84%e5%ad%98%e5%99%a8" aria-label="PC寄存器">PC寄存器</a></li>
                    <li>
                        <a href="#%e6%96%b9%e6%b3%95%e5%8c%ba" aria-label="方法区">方法区</a></li>
                    <li>
                        <a href="#%e6%a0%88" aria-label="栈">栈</a></li>
                    <li>
                        <a href="#%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%9c%ba%e5%88%b6" aria-label="双亲委派机制">双亲委派机制</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%ad%97%e8%8a%82%e7%a0%81%e6%89%a7%e8%a1%8c%e6%9c%ba%e5%88%b6" aria-label="字节码执行机制">字节码执行机制</a></li>
                    <li>
                        <a href="#gc%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" aria-label="GC垃圾回收">GC垃圾回收</a><ul>
                            
                    <li>
                        <a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95" aria-label="垃圾收集算法">垃圾收集算法</a><ul>
                            
                    <li>
                        <a href="#%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95" aria-label="标记-清除算法">标记-清除算法</a></li>
                    <li>
                        <a href="#%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95" aria-label="复制算法">复制算法</a></li>
                    <li>
                        <a href="#%e6%a0%87%e8%ae%b0-%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95" aria-label="标记-整理算法">标记-整理算法</a></li>
                    <li>
                        <a href="#%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95" aria-label="分代收集算法">分代收集算法</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#jvm%e6%80%a7%e8%83%bd%e7%9b%91%e6%8e%a7%e4%b8%8e%e6%95%85%e9%9a%9c%e5%ae%9a%e4%bd%8d" aria-label="JVM性能监控与故障定位">JVM性能监控与故障定位</a></li>
                    <li>
                        <a href="#jvm%e8%b0%83%e4%bc%98" aria-label="JVM调优">JVM调优</a></li>
                    <li>
                        <a href="#jmm" aria-label="JMM">JMM</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="面试问题">面试问题<a hidden class="anchor" aria-hidden="true" href="#面试问题">#</a></h2>
<p>谈谈对JVM的理解？java8虚拟机和以前有什么区别</p>
<p>什么是OOM？什么是栈溢出StackOverFlowError？</p>
<p>JVM的常用调优参数有哪些？</p>
<p>内存快照如何抓取，怎么分析Dump文件？</p>
<p>谈谈JVM中，类加载器的认识？</p>
<p>在一个项目中突然出现了OOM故障，该怎么排除？</p>
<p>JVM的内存模型和分区-详细到每个区放什么？</p>
<p>堆里面的分区有哪些？有什么特点？</p>
<p>GC的算法有哪些？</p>
<p>轻GC和重GC</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>首先 三者之间存在包含关系
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>JVM + 核心类库 = JRE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>JRE + java开发工具（javac.exe/jar.exe) = JDK
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="什么是jvm">什么是JVM？<a hidden class="anchor" aria-hidden="true" href="#什么是jvm">#</a></h2>
<p>Java Virtual Machine 即Java虚拟机</p>
<p>我们知道Java语言有一个独特的优点就是可以跨平台</p>
<p>像其它语言，比如C，我们要针对不同操作系统windos，mac……各出一套应用程序</p>
<p>而Java则可以做到一个软件在任何的操作系统中都能执行，这就是JVM的功劳</p>
<p>如下图
<img loading="lazy" src="https://pic2.zhimg.com/80/v2-d251cbe1cc073d3ae829fd6beeb8d899_720w.jpg" alt="Alt text"  />
</p>
<p>图片来自高新强老师JAVA课程
本来我们编写的Java代码计算机还是不认识的，但是我们在每一个操作系统上都会配置一个与之相对应的JVM，会帮我们把我们的Java代码翻译成对应操作系统可以识别的内容。</p>
<p>JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<p>Java语言中的反编译一般指将class文件转换成java文件。</p>
<p>所以说我们在第一次写Java程序时都要先把JVM给装好。</p>
<h2 id="什么是jre">什么是JRE？<a hidden class="anchor" aria-hidden="true" href="#什么是jre">#</a></h2>
<p>Java Runtime Environment 即Java运行环境</p>
<p>JVM + 核心类库 = JRE</p>
<p>刚才不是说只需要装JVM吗？那这个JRE是个什么鬼东西？</p>
<p>是因为只有JVM不能运行，它还需要核心类库，才能保证Java运行</p>
<p>由于JRE包含JVM 因此我们只要直接安装JRE 就顺便把JVM安装了</p>
<p><img loading="lazy" src="https://pic1.zhimg.com/80/v2-0dcc3179b5d9295bf6f2d9548a2404a4_720w.jpg" alt="Alt text"  />

图片来自高新强老师JAVA课程</p>
<h2 id="什么是jdk">什么是JDK?<a hidden class="anchor" aria-hidden="true" href="#什么是jdk">#</a></h2>
<p>Java Development Kit 即Java开发工具包</p>
<p>JRE + java开发工具（javac.exe/jar.exe) = JDK</p>
<p>前面不是说安装了JRE以后,Java程序就可以运行了吗?那为啥子还要安装这个JDK?</p>
<p>这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding</p>
<p>由于JDK包含JRE 因此我们只需要安装JDK就都有了</p>
<p><img loading="lazy" src="https://pic4.zhimg.com/80/v2-b53fd4f716e3b299537a631dfb422e0b_720w.jpg" alt="Alt text"  />
</p>
<h2 id="类加载机制">类加载机制<a hidden class="anchor" aria-hidden="true" href="#类加载机制">#</a></h2>
<p><img loading="lazy" src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2437359893,1046499749&amp;fm=173&amp;app=25&amp;f=JPEG?w=639&amp;h=386&amp;s=6840ED1E015C51C81A5CACF403004031" alt="Alt text"  />

类装载器（ClassLoader）（用来装载.class文件并初始化)</p>
<p>执行引擎（执行字节码，或者执行本地方法）
运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈)</p>
<h3 id="堆heap">堆（Heap）<a hidden class="anchor" aria-hidden="true" href="#堆heap">#</a></h3>
<p>它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。</p>
<p>元空间逻辑上存在，物理上不存在，不放在虚拟机内存，而存储在本地内存中</p>
<h3 id="运行时常量池runtime-constant-pool">运行时常量池（Runtime Constant Pool）<a hidden class="anchor" aria-hidden="true" href="#运行时常量池runtime-constant-pool">#</a></h3>
<p>存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。</p>
<h3 id="本地方法堆栈native-method-stacks">本地方法堆栈（Native Method Stacks）<a hidden class="anchor" aria-hidden="true" href="#本地方法堆栈native-method-stacks">#</a></h3>
<p>JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。</p>
<h3 id="pc寄存器">PC寄存器<a hidden class="anchor" aria-hidden="true" href="#pc寄存器">#</a></h3>
<p>PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。</p>
<h3 id="方法区">方法区<a hidden class="anchor" aria-hidden="true" href="#方法区">#</a></h3>
<p>方法区：static、final、Class、常量池</p>
<p>不止是存“方法”，而是存储整个 class文件的信息，JVM运行时，类加载器子系统将会提取 class文件里面的类信息，并将其存放在方法区中。例如类的名称、类的类型（枚举、类、接口）、字段、方法等等。</p>
<p>方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p>
<h3 id="栈">栈<a hidden class="anchor" aria-hidden="true" href="#栈">#</a></h3>
<p>栈：栈内存，主管程序的运行，生命周期和线程同步</p>
<ul>
<li>线程结束，栈内存就释放，对于栈来说，不存在垃圾回收问题</li>
<li>一旦线程结束，栈就over</li>
<li>栈：JVM栈中存放的为当前线程中局部8大基本类型（boolean、char、byte、short、int、long、float、double）、对象引用、实例的方法、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。</li>
<li>栈的运行原理：栈帧</li>
<li>栈满了：StackOverFlowError</li>
<li>栈+堆+方法区：交互关系</li>
<li>JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈</li>
</ul>
<h3 id="双亲委派机制">双亲委派机制<a hidden class="anchor" aria-hidden="true" href="#双亲委派机制">#</a></h3>
<p>工作原理：</p>
<p>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</p>
<p>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达项层的启动类加载器；</p>
<p>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。</p>
<p>作用：</p>
<p>1）避免核心API被篡改</p>
<p>2）避免类的重复加载</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>AppClassLoader
</span></span><span style="display:flex;"><span>ExtClassLoader
</span></span><span style="display:flex;"><span>BootstrapClassloader  <span style="color:#f00">#</span>java获取不到<span style="color:#f00">，</span>因为底层是c/c++
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="C:%5cUsers%5cWIN10%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210614221246852.png" alt="image-20210614221246852"  />
</p>
<h2 id="字节码执行机制">字节码执行机制<a hidden class="anchor" aria-hidden="true" href="#字节码执行机制">#</a></h2>
<h2 id="gc垃圾回收">GC垃圾回收<a hidden class="anchor" aria-hidden="true" href="#gc垃圾回收">#</a></h2>
<p>GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停</p>
<p>（1）对新生代的对象的收集称为minor GC；
（2）对旧生代的对象的收集称为Full GC；
（3）程序中主动调用System.gc()强制执行的GC为Full GC。</p>
<p>不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：</p>
<p>（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）
（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
（3）弱引用：在GC时一定会被GC回收
（4）虚引用：由于虚引用只是用来得知对象是否被GC</p>
<p>不同的区</p>
<h3 id="垃圾收集算法">垃圾收集算法<a hidden class="anchor" aria-hidden="true" href="#垃圾收集算法">#</a></h3>
<h4 id="标记-清除算法">标记-清除算法<a hidden class="anchor" aria-hidden="true" href="#标记-清除算法">#</a></h4>
<p><strong>适用场合</strong>：</p>
<ul>
<li>存活对象较多的情况下比较高效</li>
<li>适用于年老代（即旧生代）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收</li>
<li>扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）</li>
</ul>
<h4 id="复制算法">复制算法<a hidden class="anchor" aria-hidden="true" href="#复制算法">#</a></h4>
<p><strong>适用场合：</strong></p>
<ul>
<li>存活对象较少的情况下比较高效</li>
<li>扫描了整个空间一次（标记存活对象并复制移动）</li>
<li>适<strong>用于年轻代（即新生代）</strong>：基本上98%的对象是&quot;朝生夕死&quot;的，存活下来的会很少</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要一块儿空的内存空间</li>
<li>需要复制移动对象</li>
</ul>
<h4 id="标记-整理算法">标记-整理算法<a hidden class="anchor" aria-hidden="true" href="#标记-整理算法">#</a></h4>
<p>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。</p>
<p>首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
<h4 id="分代收集算法">分代收集算法<a hidden class="anchor" aria-hidden="true" href="#分代收集算法">#</a></h4>
<p><strong>分代收集算法就是目前虚拟机使用的回收算法</strong>，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。</p>
<p>在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率高，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。</p>
<p>步骤：</p>
<ul>
<li>当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，每次Minor GC，存活下来的对象年龄加+1</li>
<li>那什么时候会进入老年代呢？从上面看到，如果对象在GC过程中没有被回收，那么它的对象年龄（Age）会不断的增加，对象在Survivor区每熬过一个Minor GC，年龄就增加1岁，当它的年龄到达一定的程度（默认为15岁），就会被移动到老年代，这个年龄阀值可以通过<code>-XX:MaxTenuringThreshold</code>设置。</li>
</ul>
<p><strong>谁空谁是to</strong></p>
<p><strong>大对象直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。</strong></p>
<p><a href="https://www.cnblogs.com/mrhgw/p/10341660.html">详情</a>
垃圾收集算法是方法论，垃圾收集器是具体实现。JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大，这里只看HotSpot虚拟机。</p>
<h2 id="jvm性能监控与故障定位">JVM性能监控与故障定位<a hidden class="anchor" aria-hidden="true" href="#jvm性能监控与故障定位">#</a></h2>
<h2 id="jvm调优">JVM调优<a hidden class="anchor" aria-hidden="true" href="#jvm调优">#</a></h2>
<p>**对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。**<strong>1.Full GC</strong></p>
<p>会对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少Full GC的次数。</p>
<p><strong>2.导致Full GC的原因</strong></p>
<p><strong>1)*年老代（Tenured）被写满*</strong></p>
<p>调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。</p>
<p><strong>2)持久代Pemanet Generation空间不足</strong></p>
<p>增大Perm Gen空间，避免太多静态对象 ， 控制好新生代和旧生代的比例</p>
<p><strong>3)System.gc()被显示调用</strong></p>
<p>垃圾回收不要手动触发，尽量依靠JVM自身的机制</p>
<p><strong>1.监控GC的状态</strong></p>
<p>使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。</p>
<p><strong>举一个例子： 系统崩溃前的一些现象：</strong></p>
<ul>
<li>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</li>
<li>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</li>
<li>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放</li>
</ul>
<p>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。</p>
<p><strong>4.分析结果，判断是否需要优化</strong></p>
<p>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。</p>
<p><strong>注：如果满足下面的指标，则一般不需要进行GC：</strong></p>
<ul>
<li>Minor GC执行时间不到50ms；</li>
<li>Minor GC执行不频繁，约10秒一次；</li>
<li>Full GC执行时间不到1s；</li>
<li>Full GC执行频率不算频繁，不低于10分钟1次；</li>
</ul>
<p><strong>5.调整GC类型和内存分配</strong></p>
<p>如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。</p>
<p><strong>6.不断的分析和调整</strong></p>
<p>通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些<strong>参数应用到所有服务器。</strong></p>
<p>JVM调优参数参考</p>
<p>1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，<strong>为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;</strong></p>
<p><strong>2.年轻代和年老代将根据默认的比例（1：2）分配堆内存</strong>， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。</p>
<p>比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。</p>
<p>3.年轻代和年老代设置多大才算合理</p>
<p><strong>1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC</strong></p>
<p><strong>2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率</strong></p>
<p>如何选择应该依赖应用程序<strong>对象生命周期的分布情况</strong>： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。</p>
<p><strong>在抉择时应该根 据以下两点：</strong></p>
<p>（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。</p>
<p>（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。</p>
<p><strong>4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法</strong>： <strong>-XX:+UseParallelOldGC</strong> <strong>。</strong></p>
<p><strong>5.线程堆栈的设置</strong>：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。</p>
<p>理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>
<h2 id="jmm">JMM<a hidden class="anchor" aria-hidden="true" href="#jmm">#</a></h2>
<p>java 内存模型</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kevinerr.github.io/tags/java/">java</a></li>
      <li><a href="https://kevinerr.github.io/tags/jvm/">jvm</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://kevinerr.github.io/posts/tech/redis/">
    <span class="title">« Prev Page</span>
    <br>
    <span>redis学习笔记</span>
  </a>
  <a class="next" href="https://kevinerr.github.io/posts/tech/latex/">
    <span class="title">Next Page »</span>
    <br>
    <span></span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share jvm on twitter"
        href="https://twitter.com/intent/tweet/?text=jvm&amp;url=https%3a%2f%2fkevinerr.github.io%2fposts%2ftech%2fjvm%2f&amp;hashtags=java%2cjvm">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share jvm on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkevinerr.github.io%2fposts%2ftech%2fjvm%2f&amp;title=jvm&amp;summary=jvm&amp;source=https%3a%2f%2fkevinerr.github.io%2fposts%2ftech%2fjvm%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share jvm on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fkevinerr.github.io%2fposts%2ftech%2fjvm%2f&title=jvm">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share jvm on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkevinerr.github.io%2fposts%2ftech%2fjvm%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share jvm on whatsapp"
        href="https://api.whatsapp.com/send?text=jvm%20-%20https%3a%2f%2fkevinerr.github.io%2fposts%2ftech%2fjvm%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share jvm on telegram"
        href="https://telegram.me/share/url?text=jvm&amp;url=https%3a%2f%2fkevinerr.github.io%2fposts%2ftech%2fjvm%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>
    <div id="tcomment"></div>
    <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.0/dist/twikoo.all.min.js"></script>
    <script>
        twikoo.init({
            envId: "https://twikoo-two-psi.vercel.app/",  
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou',  
            path: 'window.TWIKOO_MAGIC_PATH||window.location.pathname',
        });
    </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://kevinerr.github.io/">hkh&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
